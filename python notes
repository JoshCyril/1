









# Python Mastery: From Zero to Hero in Automation, Web Scraping & Data Analytics

## Table of Contents

1. [Python Fundamentals: Your First Steps into Programming](#python-fundamentals-your-first-steps-into-programming)
2. [Control Flow and Functions: The Logic of Programming](#control-flow-and-functions-the-logic-of-programming)
3. [Data Structures and Collections: Organizing Information](#data-structures-and-collections-organizing-information)
4. [Object-Oriented Programming: Building Robust and Reusable Code](#object-oriented-programming-building-robust-and-reusable-code)
5. [Modules, Packages, and File Handling: Expanding Python's Capabilities](#modules-packages-and-file-handling-expanding-pythons-capabilities)
6. [Exception Handling and Debugging: Writing Resilient Code](#exception-handling-and-debugging-writing-resilient-code)
7. [Functional Programming and Advanced Concepts: Elevating Your Python Skills](#functional-programming-and-advanced-concepts-elevating-your-python-skills)
8. [Web Scraping Fundamentals: Extracting Data from the Web](#web-scraping-fundamentals-extracting-data-from-the-web)
9. [Data Analytics with Python: From Raw Data to Insights](#data-analytics-with-python-from-raw-data-to-insights)
10. [Workflow Automation: Streamlining Your Tasks with Python](#workflow-automation-streamlining-your-tasks-with-python)
11. [Advanced Python Topics: Preparing for the Real World](#advanced-python-topics-preparing-for-the-real-world)

---

## Python Fundamentals: Your First Steps into Programming

Welcome to the exciting world of Python! This chapter will lay the foundation for your entire journey. We'll start by understanding what Python is and why it has become one of the most popular programming languages globally. Python is renowned for its simplicity, readability, and versatility, making it an excellent choice for beginners and a powerful tool for experts in fields ranging from web development and data science to artificial intelligence and automation. We will walk you through setting up your programming environment, a crucial first step that involves installing Python and choosing a code editor. Then, we'll dive into writing your very first program, the classic "Hello, World!", which will give you an immediate sense of accomplishment. From there, we'll explore the fundamental building blocks of any program: variables, which are like containers for storing data, and Python's basic data types, such as integers for whole numbers, floats for decimal numbers, strings for text, and booleans for representing truth values. You'll learn how to perform basic operations with these data types and how to use Python's built-in `input()` function to make your programs interactive. By the end of this chapter, you will have a solid grasp of Python's basic syntax and be ready to tackle more complex programming concepts.

### Core Concepts

*   **What is Python?** A high-level, interpreted, general-purpose programming language known for its emphasis on code readability.
*   **Setting up your environment:** Installing Python from [python.org](https://www.python.org/) and selecting a code editor like Visual Studio Code, PyCharm, or even a simple online interpreter like Replit.
*   **Your first program:** Writing and executing `print("Hello, World!")`.
*   **Variables and Assignment:** Using variables (e.g., `message = "Hello, Python!"`) to store data.
*   **Basic Data Types:**
    *   **Integers (`int`):** Whole numbers (e.g., `10`, `-5`, `0`).
    *   **Floating-Point Numbers (`float`):** Numbers with decimal points (e.g., `3.14`, `-0.001`, `2.0`).
    *   **Strings (`str`):** Sequences of characters enclosed in single, double, or triple quotes (e.g., `'Python'`, `"Data Science"`, `'''Multi-line string'''`).
    *   **Booleans (`bool`):** Represents either `True` or `False`.
*   **Basic Operators:**
    *   **Arithmetic:** `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), `%` (modulo), `**` (exponentiation).
    *   **String Concatenation:** Using `+` to join strings (e.g., `"Hello" + " " + "World"`).
    *   **Comparison:** `==` (equal to), `!=` (not equal to), `>` (greater than), `<` (less than), `>=` (greater than or equal to), `<=` (less than or equal to).
*   **User Input:** Using the `input()` function to get data from the user (e.g., `name = input("What is your name? ")`).
*   **Basic Type Conversion:** Converting between data types using functions like `int()`, `str()`, and `float()`.

### Code Examples

```python
# Hello, World!
print("Hello, World!")

# Variables and basic data types
age = 25  # Integer
price = 19.99  # Float
name = "Alice"  # String
is_student = True  # Boolean

print(f"Name: {name}, Age: {age}, Price: {price}, Is Student: {is_student}")

# Basic arithmetic operations
sum_result = 10 + 5
difference = 10 - 5
product = 10 * 5
quotient = 10 / 5
power = 2 ** 3
modulo = 10 % 3  # Remainder of division

print(f"Sum: {sum_result}, Difference: {difference}, Product: {product}, Quotient: {quotient}")
print(f"Power: {power}, Modulo: {modulo}")

# String operations
greeting = "Hello"
name = "Bob"
full_greeting = greeting + ", " + name + "!"
print(full_greeting)

# User input and type conversion
user_age_str = input("Please enter your age: ")
user_age_int = int(user_age_str)
years_to_100 = 100 - user_age_int
print(f"You will be 100 in {years_to_100} years.")
```

### Projects/Tasks

Choose one of the following projects to apply what you've learned:

1.  **Simple Calculator:** Create a program that asks the user for two numbers and an operation (addition, subtraction, multiplication, or division) and then prints the result of that operation.
    *   **Detailed Steps:**
        1.  Prompt the user to enter the first number. Convert this input to a float.
        2.  Prompt the user to enter the second number. Convert this input to a float.
        3.  Prompt the user to enter an operator (+, -, *, /).
        4.  Use `if/elif/else` statements to perform the chosen arithmetic operation.
        5.  Print the result in a user-friendly format (e.g., "5.0 + 3.0 = 8.0").
        6.  Consider handling division by zero.

2.  **Personal Information Formatter:** Write a script that asks the user for their first name, last name, age, and city. Then, print a formatted sentence that combines all this information.
    *   **Detailed Steps:**
        1.  Use `input()` to get the user's first name, last name, age, and city.
        2.  Remember to convert the age to an integer.
        3.  Use an f-string to create a well-formatted output sentence, for example: "Hello, [First Name] [Last Name]. You are [Age] years old and live in [City]."
        4.  Print the formatted sentence.

### Next Steps

Once you are comfortable with variables, basic data types, and simple I/O operations, you're ready to move on to the next chapter: **Control Flow and Functions**. There, you'll learn how to make your programs make decisions and perform repetitive tasks, which are fundamental to creating more complex and useful applications.

---

## Control Flow and Functions: The Logic of Programming

In this chapter, we will explore the mechanisms that allow your programs to execute different blocks of code based on certain conditions and to repeat actions efficiently. This is known as control flow, and it's what makes your programs dynamic and responsive. We'll start with conditional statements, primarily `if`, `elif`, and `else`, which enable your program to make decisions. For example, you can check if a user's input is valid or if a number is even or odd. Next, we'll delve into loops, which are used for iteration. The `for` loop is ideal for iterating over a sequence of items (like a list of names or a range of numbers), while the `while` loop continues to execute as long as a certain condition remains true. We'll also cover loop control statements like `break` (to exit a loop prematurely) and `continue` (to skip the rest of the current iteration and move to the next one). The second major part of this chapter introduces functions. Functions are reusable blocks of code that perform a specific task. They are essential for writing organized, modular, and maintainable programs. You will learn how to define your own functions using the `def` keyword, how to pass information to them via parameters, and how to get results back using `return` statements. We'll also discuss variable scope, which determines where a variable can be accessed within your code, and the concept of docstrings, which are used to document what your functions do.

### Core Concepts

*   **Conditional Statements (`if`, `elif`, `else`):** Executing code blocks based on whether conditions are `True` or `False`.
    *   `if condition:`
    *   `elif another_condition:`
    *   `else:`
*   **Comparison Operators:** `==`, `!=`, `>`, `<`, `>=`, `<=`.
*   **Logical Operators:** `and`, `or`, `not` to combine or modify conditions.
*   **Loops for Iteration:**
    *   **`for` loops:** Iterating over sequences (strings, lists, tuples, dictionaries, sets) or a range of numbers using `range()`.
    *   **`while` loops:** Repeating a block of code as long as a condition is true.
*   **Loop Control Statements:**
    *   `break`: Exits the current loop entirely.
    *   `continue`: Skips the rest of the current iteration and proceeds to the next.
*   **Functions:**
    *   **Defining functions:** Using the `def` keyword (e.g., `def my_function(parameters):`).
    *   **Parameters and Arguments:** Passing data into functions.
    *   **The `return` statement:** Sending a result back from a function.
    *   **Default Parameter Values:** Providing default values for parameters.
    *   **Scope of Variables:** Understanding local vs. global variables.
    *   **Docstrings:** Writing documentation for functions (e.g., `"""This function does something."""`).

### Code Examples

```python
# Conditional statements
age = 20

if age < 18:
    print("You are a minor.")
elif age >= 18 and age < 65:
    print("You are an adult.")
else:
    print("You are a senior citizen.")

# Logical operators
is_raining = True
has_umbrella = False

if is_raining and not has_umbrella:
    print("You will get wet.")
elif is_raining and has_umbrella:
    print("You will stay dry.")
else:
    print("Enjoy the sunshine!")

# For loops
print("\nCounting with a for loop:")
for i in range(5):  # range(5) generates numbers 0 through 4
    print(i)

fruits = ["apple", "banana", "cherry"]
print("\nFruits:")
for fruit in fruits:
    print(fruit.capitalize())

# While loops
print("\nCountdown with a while loop:")
countdown = 5
while countdown > 0:
    print(countdown)
    countdown -= 1
print("Blast off!")

# Break and continue
print("\nFinding 'banana':")
for fruit in fruits:
    if fruit == "banana":
        print("Found banana!")
        break # Exit the loop once banana is found

print("\nSkipping 'banana':")
for fruit in fruits:
    if fruit == "banana":
        continue # Skip this iteration
    print(fruit)

# Functions
def greet(name, greeting="Hello"):
    """Greets a person with a specified greeting."""
    return f"{greeting}, {name}!"

message1 = greet("Alice")
message2 = greet("Bob", "Good morning")
print(f"\n{message1}")
print(message2)

def add_numbers(a, b):
    """Adds two numbers and returns the result."""
    return a + b

result = add_numbers(10, 5)
print(f"\nSum: {result}")

# Function with multiple return values
def get_min_max(numbers_list):
    """Returns the minimum and maximum from a list of numbers."""
    if not numbers_list:
        return None, None
    return min(numbers_list), max(numbers_list)

nums = [4, 2, 9, 5, 1]
minimum, maximum = get_min_max(nums)
print(f"\nList: {nums}, Min: {minimum}, Max: {maximum}")
```

### Projects/Tasks

Choose one of the following projects to practice control flow and functions:

1.  **Number Guesser Game:** Create a game where the computer randomly selects a number between 1 and 100, and the user has to guess it. The program should provide hints like "Too high!" or "Too low!" and count the number of attempts.
    *   **Detailed Steps:**
        1.  Import the `random` module (`import random`).
        2.  Generate a random integer between 1 and 100: `secret_number = random.randint(1, 100)`.
        3.  Initialize a variable for the number of attempts (e.g., `attempts = 0`).
        4.  Use a `while True` loop to keep asking the user for their guess.
        5.  Inside the loop, increment the `attempts` counter.
        6.  Convert the user's input to an integer.
        7.  Use `if/elif/else` to compare the guess with `secret_number`:
            *   If `guess < secret_number`, print "Too low!".
            *   If `guess > secret_number`, print "Too high!".
            *   If `guess == secret_number`, print a congratulatory message with the number of attempts and `break` the loop.
        8.  Handle potential `ValueError` if the user enters non-numeric input.

2.  **Simple To-Do List Application:** Build a command-line to-do list where users can add tasks, view all tasks, and mark tasks as complete.
    *   **Detailed Steps:**
        1.  Create an empty list to store tasks. Each task can be a dictionary, e.g., `{"description": "Buy groceries", "completed": False}`.
        2.  Create functions for each action:
            *   `add_task(task_list)`: Prompts the user for a task description and appends a new task dictionary to the list.
            *   `view_tasks(task_list)`: Iterates through the task list and prints each task with its status (e.g., "[ ] Buy groceries" or "[X] Walk the dog").
            *   `complete_task(task_list)`: Asks the user for the index of the task to mark as complete and updates its `completed` status to `True`.
        3.  Use a `while` loop to display a menu of options (e.g., "1. Add Task", "2. View Tasks", "3. Complete Task", "4. Exit").
        4.  Based on the user's choice, call the corresponding function.
        5.  The loop should continue until the user chooses to exit.

### Next Steps

Mastering control flow and functions is a significant milestone. You can now write programs that make decisions and perform repetitive tasks in an organized way. The next step is to learn about **Data Structures and Collections**, which will allow you to store and manage more complex and larger sets of data efficiently.

---

## Data Structures and Collections: Organizing Information

As you progress in programming, you'll often need to work with collections of data, not just individual variables. Python provides powerful built-in data structures to handle this. This chapter will introduce you to the most fundamental ones: lists, tuples, sets, and dictionaries. A **list** is an ordered, mutable (changeable) collection of items, which makes it perfect for sequences that might need to be modified, like a to-do list or a collection of student grades. You'll learn how to create lists, add, remove, and access elements, and discover common list methods like `append()`, `insert()`, `pop()`, and `sort()`. A **tuple** is similar to a list but is immutable (unchangeable) once created. This immutability makes tuples useful for data that should not be altered, such as coordinates or configuration settings. **Sets** are unordered collections of unique elements. They are incredibly efficient for checking membership (whether an item is in the set) and for performing mathematical set operations like union, intersection, and difference. Finally, **dictionaries** are one of Python's most powerful data structures. They store data as key-value pairs, allowing for highly efficient lookup of values based on their unique keys. Think of a real-world dictionary where you look up a word (the key) to find its definition (the value). We will cover how to create dictionaries, access, add, and modify key-value pairs, and iterate through them. Understanding when and how to use each of these data structures is crucial for writing efficient and well-organized Python code.

### Core Concepts

*   **Lists (`list`):**
    *   Ordered, mutable (changeable) sequences.
    *   Creating lists: `my_list = [1, "hello", 3.14]`.
    *   Accessing elements: Indexing (`my_list[0]`) and slicing (`my_list[1:3]`).
    *   Common methods: `append()`, `insert()`, `extend()`, `remove()`, `pop()`, `clear()`, `index()`, `count()`, `sort()`, `reverse()`.
    *   List comprehensions: A concise way to create lists (e.g., `[x**2 for x in range(10)]`).
*   **Tuples (`tuple`):**
    *   Ordered, immutable (unchangeable) sequences.
    *   Creating tuples: `my_tuple = (1, "hello", 3.14)` or `my_tuple = 1, "hello", 3.14`.
    *   Accessing elements: Similar to lists, via indexing and slicing.
    *   Use cases: For fixed data, dictionary keys, returning multiple values from functions.
*   **Sets (`set`):**
    *   Unordered collections of unique, immutable elements.
    *   Creating sets: `my_set = {1, 2, 3}` or `my_set = set([1, 2, 2, 3])` (results in `{1, 2, 3}`).
    *   Common methods: `add()`, `remove()`, `discard()`, `clear()`, `union()` (or `|`), `intersection()` (or `&`), `difference()` (or `-`).
*   **Dictionaries (`dict`):**
    *   Unordered collections of key-value pairs (keys must be immutable and unique).
    *   Creating dictionaries: `my_dict = {"name": "Alice", "age": 30}`.
    *   Accessing values: By key (`my_dict["name"]`) or using the `.get()` method (which allows a default value if key is not found).
    *   Modifying/Adding key-value pairs: `my_dict["age"] = 31` or `my_dict["city"] = "New York"`.
    *   Removing key-value pairs: `del my_dict["name"]` or `.pop("name")`.
    *   Common methods: `keys()`, `values()`, `items()`, `update()`.
    *   Dictionary comprehensions: A concise way to create dictionaries (e.g., `{x: x**2 for x in range(5)}`).
*   **Choosing the right data structure:** Understanding the trade-offs (mutability, order, uniqueness, performance).

### Code Examples

```python
# Lists
print("--- Lists ---")
fruits = ["apple", "banana", "cherry"]
print(f"Original list: {fruits}")
print(f"First fruit: {fruits[0]}")
print(f"Last fruit: {fruits[-1]}")

fruits.append("orange")  # Add to end
print(f"After append: {fruits}")
fruits.insert(1, "mango") # Insert at index 1
print(f"After insert: {fruits}")
removed_fruit = fruits.pop(2) # Remove item at index 2
print(f"Popped item: {removed_fruit}, List after pop: {fruits}")
fruits.sort() # Sorts alphabetically
print(f"Sorted list: {fruits}")

# List comprehension
squares = [x**2 for x in range(10)]
print(f"Squares: {squares}")

# Tuples
print("\n--- Tuples ---")
coordinates = (10, 20)
print(f"Coordinates: {coordinates}")
print(f"X-coordinate: {coordinates[0]}")
# tuples are immutable, so coordinates[0] = 15 would raise a TypeError

# Sets
print("\n--- Sets ---")
unique_numbers = {1, 2, 3, 2, 1, 4}
print(f"Unique numbers: {unique_numbers}") # Output will be {1, 2, 3, 4}

set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}
print(f"Set A: {set_a}")
print(f"Set B: {set_b}")
print(f"Union (A | B): {set_a.union(set_b)}")
print(f"Intersection (A & B): {set_a.intersection(set_b)}")
print(f"Difference (A - B): {set_a.difference(set_b)}")

# Dictionaries
print("\n--- Dictionaries ---")
student = {"name": "Charlie", "age": 22, "courses": ["History", "Math"]}
print(f"Student info: {student}")
print(f"Student name: {student['name']}")
print(f"Student courses: {student['courses']}")

student["age"] = 23 # Update value
student["phone"] = "123-456-7890" # Add new key-value pair
print(f"Updated student info: {student}")

# Iterating through a dictionary
print("\nIterating through dictionary:")
for key, value in student.items():
    print(f"{key}: {value}")

# Dictionary comprehension
word_lengths = {"hello": 5, "world": 5, "python": 6}
print(f"Word lengths: {word_lengths}")
```

### Projects/Tasks

Choose one of the following projects to solidify your understanding of data structures:

1.  **Contact Book:** Develop a simple contact book application using a dictionary to store contact information. Each contact should be a dictionary itself, and all contacts should be stored in a main dictionary, perhaps with a unique ID or email as the key. The program should allow users to add new contacts, search for existing contacts by name or email, and display all contacts.
    *   **Detailed Steps:**
        1.  Create a main dictionary to store contacts, e.g., `contacts = {}`.
        2.  Each contact can be a dictionary: `contact_details = {"name": "David", "phone": "987-654-3210", "email": "david@example.com"}`.
        3.  Use a unique identifier (like the email) as the key for the main `contacts` dictionary: `contacts["david@example.com"] = contact_details`.
        4.  Create functions:
            *   `add_contact(contacts_dict)`: Prompts for name, phone, email, and adds the new contact to the dictionary.
            *   `search_contact(contacts_dict, search_term)`: Iterates through the contacts and prints details for any contact whose name or email matches the `search_term`.
            *   `display_all_contacts(contacts_dict)`: Prints all stored contacts in a readable format.
        5.  Use a `while` loop to present a menu (Add, Search, Display All, Exit) and call the appropriate functions.

2.  **Word Frequency Counter:** Write a script that takes a text string (or reads from a file) and counts the frequency of each word. The program should then display the words and their counts, perhaps sorted by frequency or alphabetically.
    *   **Detailed Steps:**
        1.  Define a sample text string or read from a file.
        2.  Convert the entire text to lowercase to make the counting case-insensitive.
        3.  Remove punctuation from the text (you might need to import the `string` module and use `string.punctuation`).
        4.  Split the text into a list of words using `text.split()`.
        5.  Create an empty dictionary `word_counts = {}`.
        6.  Iterate through the list of words:
            *   For each word, if it's already a key in `word_counts`, increment its count.
            *   Otherwise, add the word as a key to `word_counts` with a count of 1.
            *   (Alternatively, you can use `collections.Counter` for a more concise solution, but try implementing it manually first).
        7.  Display the results, perhaps sorted by count in descending order. You can use `sorted(word_counts.items(), key=lambda item: item[1], reverse=True)`.

### Next Steps

With a good grasp of Python's core data structures, you're well-equipped to handle more complex data organization. Now, it's time to explore **Object-Oriented Programming (OOP)**, a paradigm that will help you structure your code in a more modular and reusable way by creating custom objects that bundle data and functionality together.

---

## Object-Oriented Programming: Building Robust and Reusable Code

Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around "objects," which can contain data (attributes) and code (methods). This approach helps in managing complexity by breaking down large programs into smaller, self-contained, and reusable components. This chapter will introduce you to the core principles of OOP in Python. We'll start by understanding what a **class** isâ€”a blueprint for creating objects. You'll learn how to define your own classes using the `class` keyword and how to create instances (objects) from those classes. Each object will have its own set of attributes, which are variables that belong to the object, and methods, which are functions that belong to the object and can operate on its attributes. A special method called the **constructor (`__init__`)** is used to initialize an object's attributes when it is created. We will then delve into the four main pillars of OOP: **Encapsulation**, which bundles data and methods that operate on that data within a single unit (the class) and restricts direct access to some of an object's components; **Abstraction**, which hides complex implementation details and shows only the essential features of the object; **Inheritance**, which allows a new class (subclass or child class) to inherit attributes and methods from an existing class (superclass or parent class), promoting code reuse; and **Polymorphism**, which allows objects of different classes to be treated as objects of a common superclass, often through method overriding (where a subclass provides a specific implementation of a method that is already defined in its superclass). Understanding OOP is fundamental to building scalable, maintainable, and robust applications.

### Core Concepts

*   **Classes and Objects:**
    *   **Class:** A blueprint for creating objects. Defined using the `class` keyword (e.g., `class Dog:`).
    *   **Object (Instance):** A specific realization of a class.
    *   **Attributes:** Variables that belong to an object/class (data).
    *   **Methods:** Functions that belong to an object/class (behavior).
*   **The `__init__` Method (Constructor):** A special method that is automatically called when a new object is instantiated. It's used to initialize the object's attributes.
*   **`self` Parameter:** A reference to the current instance of the class. It must be the first parameter of instance methods.
*   **Encapsulation:**
    *   Bundling data (attributes) and methods that operate on the data within a class.
    *   Controlling access to object internals using naming conventions (e.g., a single leading underscore `_var` for "protected" attributes, double leading underscore `__var` for "private" attributes, which triggers name mangling).
*   **Abstraction:** Hiding complex implementation details and showing only the necessary features of an object. Achieved through well-defined class interfaces.
*   **Inheritance:**
    *   Creating a new class (child/subclass) that inherits attributes and methods from an existing class (parent/superclass).
    *   Syntax: `class ChildClass(ParentClass):`
    *   The `super()` function is used to call methods from the parent class.
*   **Polymorphism:**
    *   "Many forms." The ability of different objects to respond to the same method call in their own specific ways.
    *   Often achieved through method overriding (a subclass provides its own implementation of a method already defined in its superclass).
*   **Class Attributes vs. Instance Attributes:**
    *   **Instance Attributes:** Belong to a specific instance of a class. Typically defined in `__init__`.
    *   **Class Attributes:** Belong to the class itself and are shared by all instances of that class. Defined directly within the class body.

### Code Examples

```python
# Basic Class and Object
print("--- Basic Class and Object ---")
class Dog:
    # Class attribute
    species = "Canis familiaris"

    # Initializer / Instance Attributes
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # Instance method
    def description(self):
        return f"{self.name} is {self.age} years old."

    # Another instance method
    def speak(self, sound):
        return f"{self.name} says {sound}."

# Create instances (objects) of the Dog class
dog1 = Dog("Buddy", 5)
dog2 = Dog("Lucy", 3)

print(f"{dog1.name} is a {dog1.species}.")
print(dog1.description())
print(dog1.speak("Woof Woof"))
print(f"\n{dog2.name} is also a {dog2.species}.")
print(dog2.speak("Meow")) # Even though it's a dog, we can make it say anything

# Inheritance
print("\n--- Inheritance ---")
class Cat(Dog): # Cat inherits from Dog
    def __init__(self, name, age, favorite_toy):
        super().__init__(name, age) # Call parent's __init__
        self.favorite_toy = favorite_toy

    # Override the speak method
    def speak(self, sound="Purr"):
        return f"{self.name} says {sound}."

    def play(self):
        return f"{self.name} is playing with its {self.favorite_toy}."

cat1 = Cat("Whiskers", 2, "yarn ball")
print(cat1.description()) # Inherited method
print(cat1.speak())       # Overridden method
print(cat1.play())        # Cat-specific method

# Polymorphism example
print("\n--- Polymorphism ---")
def make_animal_speak(animal):
    print(animal.speak())

make_animal_speak(dog1)
make_animal_speak(cat1)

# Encapsulation (using naming conventions)
print("\n--- Encapsulation ---")
class BankAccount:
    def __init__(self, balance):
        self._balance = balance  # "Protected" attribute by convention

    def deposit(self, amount):
        if amount > 0:
            self._balance += amount
            print(f"Deposited ${amount}. New balance: ${self._balance}")
        else:
            print("Invalid deposit amount.")

    def _calculate_interest(self): # "Protected" method
        # Some complex calculation
        return self._balance * 0.05

    def get_balance(self):
        # Public method to access balance, potentially with interest
        return self._balance + self._calculate_interest()

my_account = BankAccount(1000)
my_account.deposit(500)
print(f"Current balance (with interest): ${my_account.get_balance()}")
# Direct access to _balance is possible but discouraged by convention
# print(my_account._balance)
```

### Projects/Tasks

Choose one of the following projects to apply OOP principles:

1.  **Library Management System:** Design a simple library system using OOP. Create classes for `Book`, `Member`, and `Library`.
    *   **Detailed Steps:**
        1.  **`Book` Class:**
            *   Attributes: `title`, `author`, `isbn`, `is_available` (boolean, default `True`).
            *   Methods: `__str__` (to return a string representation of the book), `check_out()` (sets `is_available` to `False`), `return_book()` (sets `is_available` to `True`).
        2.  **`Member` Class:**
            *   Attributes: `member_id`, `name`, `borrowed_books` (a list to store `Book` objects or their ISBNs).
            *   Methods: `borrow_book(book_object)` (adds book to `borrowed_books` if available), `return_book(book_object)` (removes book from `borrowed_books`).
        3.  **`Library` Class:**
            *   Attributes: `books` (a list or dictionary of `Book` objects), `members` (a list or dictionary of `Member` objects).
            *   Methods: `add_book(book_object)`, `register_member(member_object)`, `lend_book(member_id, isbn)`, `receive_returned_book(member_id, isbn)`.
        4.  Create a simple command-line interface to interact with your library system (e.g., add books, register members, lend books, return books).

2.  **Simple Shape Hierarchy:** Create a base class `Shape` with an abstract method `area()` and `perimeter()`. Then, create subclasses like `Circle`, `Rectangle`, and `Triangle` that inherit from `Shape` and implement these methods. Each subclass will have its own specific attributes (e.g., radius for `Circle`, length and width for `Rectangle`).
    *   **Detailed Steps:**
        1.  **`Shape` Class:**
            *   It can have an `__init__` method if there are common attributes, or it can be more abstract.
            *   Define methods `area(self)` and `perimeter(self)`. These can raise `NotImplementedError` if you want to force subclasses to implement them, making `Shape` an abstract base class conceptually.
        2.  **`Circle` Class (inherits from `Shape`):**
            *   `__init__(self, radius)`
            *   Implement `area(self)` (returns `math.pi * radius**2`).
            *   Implement `perimeter(self)` (returns `2 * math.pi * radius`). You'll need to `import math`.
        3.  **`Rectangle` Class (inherits from `Shape`):**
            *   `__init__(self, length, width)`
            *   Implement `area(self)` (returns `length * width`).
            *   Implement `perimeter(self)` (returns `2 * (length + width)`).
        4.  **`Triangle` Class (inherits from `Shape`):**
            *   `__init__(self, side1, side2, side3)` (or base and height for area, if you prefer Heron's formula).
            *   Implement `area(self)` (e.g., using Heron's formula or `0.5 * base * height` if you have those attributes).
            *   Implement `perimeter(self)` (returns `side1 + side2 + side3`).
        5.  Create instances of these shapes and demonstrate calculating their area and perimeter. You can create a list of different shape objects and iterate through them, calling their `area()` and `perimeter()` methods to showcase polymorphism.

### Next Steps

You've now learned how to structure your code using classes and objects, which is a cornerstone of modern software development. The next logical step is to explore how to organize your classes and functions into larger, more manageable units. This leads us to **Modules, Packages, and File Handling**.

---

## Modules, Packages, and File Handling: Expanding Python's Capabilities

As your programs grow in complexity, you'll want to organize your code into logical, reusable units. Python's module and package system allows you to do just that. A **module** is simply a file containing Python definitions and statements (e.g., functions, classes, variables). You can use modules from Python's extensive standard library or create your own. To use code from a module, you import it using the `import` statement. A **package** is a way of structuring Python's module namespace by using "dotted module names." For example, the module name `mypackage.mymodule` suggests a module named `mymodule` in a package named `mypackage`. A package is essentially a directory containing Python modules and a special `__init__.py` file (which can be empty in Python 3). This chapter will also cover **file handling**, a crucial skill for any programmer. You will learn how to open files for reading or writing using the `open()` function, different file modes (like 'r' for read, 'w' for write, 'a' for append), and the importance of properly closing files using the `close()` method or, even better, by using the `with` statement, which ensures files are automatically closed even if errors occur. We'll explore reading file content (e.g., `read()`, `readline()`, `readlines()`) and writing content to files (e.g., `write()`, `writelines()`). Additionally, we'll touch upon working with different file formats like CSV (Comma-Separated Values) and JSON (JavaScript Object Notation), which are ubiquitous for data storage and exchange, using Python's built-in `csv` and `json` modules.

### Core Concepts

*   **Modules:**
    *   A single Python file (`.py`) containing definitions and statements.
    *   Importing modules: `import module_name`, `from module_name import function_name`, `import module_name as alias`.
    *   The `dir()` function to see names defined in a module.
*   **Packages:**
    *   A collection of modules organized in directories.
    *   Must contain an `__init__.py` file (can be empty in Python 3+) to be treated as a package.
    *   Allows for hierarchical structuring of modules (e.g., `package.subpackage.module`).
*   **Python Standard Library:** A vast collection of pre-installed modules and packages for various tasks (e.g., `math`, `os`, `sys`, `datetime`, `random`, `json`, `csv`).
*   **File I/O (Input/Output):**
    *   Opening files: `file_object = open("filename.txt", "mode")`.
    *   File modes: `'r'` (read), `'w'` (write, truncates existing file), `'a'` (append), `'r+'` (read and write), `'b'` (binary mode, e.g., `'rb'`, `'wb'`).
    *   Reading from files:
        *   `file_object.read()`: Reads entire file content as a string.
        *   `file_object.readline()`: Reads a single line.
        *   `file_object.readlines()`: Reads all lines into a list of strings.
        *   Iterating directly over the file object: `for line in file_object:`
    *   Writing to files:
        *   `file_object.write("string")`: Writes a string to the file.
        *   `file_object.writelines(list_of_strings)`: Writes a list of strings to the file.
    *   Closing files: `file_object.close()`.
    *   The `with` statement for automatic file handling: `with open("filename.txt", "r") as file_object:`. This is the recommended approach.
*   **Working with CSV Files:**
    *   `import csv`
    *   `csv.reader()` for reading CSV files.
    *   `csv.writer()` for writing to CSV files.
*   **Working with JSON Files:**
    *   `import json`
    *   `json.load()` to parse JSON from a file object.
    *   `json.loads()` to parse JSON from a string.
    *   `json.dump()` to write Python objects to a JSON file.
    *   `json.dumps()` to convert Python objects to a JSON string.
*   **`os` and `sys` modules:**
    *   `os`: Provides a way of using operating system-dependent functionality (e.g., file path manipulation, `os.path.join()`, `os.listdir()`, `os.makedirs()`).
    *   `sys`: Provides access to system-specific parameters and functions (e.g., command-line arguments via `sys.argv`, `sys.exit()`).

### Code Examples

```python
# --- Modules ---
import math
from datetime import datetime, date
import random as rnd

print(f"Pi value: {math.pi}")
print(f"Square root of 16: {math.sqrt(16)}")

now = datetime.now()
print(f"Current date and time: {now}")
today = date.today()
print(f"Today's date: {today}")

print(f"Random number between 1 and 10: {rnd.randint(1, 10)}")
colors = ["red", "green", "blue", "yellow"]
print(f"Random color: {rnd.choice(colors)}")

# --- File I/O ---
# Writing to a file
file_to_write = "my_file.txt"
try:
    with open(file_to_write, "w") as f:
        f.write("Hello, this is the first line.\n")
        f.write("This is the second line.\n")
        lines_to_write = ["Third line.\n", "Fourth line.\n"]
        f.writelines(lines_to_write)
    print(f"Successfully wrote to {file_to_write}")
except IOError as e:
    print(f"Error writing to file: {e}")

# Reading from a file
file_to_read = "my_file.txt"
try:
    with open(file_to_read, "r") as f:
        print("\n--- Reading entire file ---")
        content = f.read()
        print(content)

    with open(file_to_read, "r") as f:
        print("\n--- Reading line by line ---")
        for line in f:
            print(line.strip()) # .strip() removes leading/trailing whitespace including \n

except FileNotFoundError:
    print(f"Error: The file {file_to_read} was not found.")
except IOError as e:
    print(f"Error reading from file: {e}")

# --- Working with JSON ---
import json

data_to_save = {
    "name": "Eve",
    "age": 28,
 "is_student": False,
    "courses": ["Biology", "Chemistry"]
}

json_file = "data.json"
# Writing JSON to a file
try:
    with open(json_file, "w") as f:
        json.dump(data_to_save, f, indent=4) # indent=4 for pretty printing
    print(f"\nSuccessfully saved data to {json_file}")
except IOError as e:
    print(f"Error writing JSON file: {e}")

# Reading JSON from a file
try:
    with open(json_file, "r") as f:
        loaded_data = json.load(f)
    print(f"Successfully loaded data from {json_file}:")
    print(loaded_data)
    print(f"Name: {loaded_data['name']}")
except FileNotFoundError:
    print(f"Error: The JSON file {json_file} was not found.")
except json.JSONDecodeError:
    print(f"Error: Could not decode JSON from {json_file}.")
except IOError as e:
    print(f"Error reading JSON file: {e}")

# --- Working with CSV ---
import csv

csv_file_to_write = "students.csv"
student_data = [
    ["Name", "Age", "Grade"],
    ["Frank", 19, "A"],
    ["Grace", 20, "B"],
    ["Henry", 21, "A"]
]

try:
    with open(csv_file_to_write, "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerows(student_data)
    print(f"\nSuccessfully wrote to {csv_file_to_write}")
except IOError as e:
    print(f"Error writing CSV file: {e}")

csv_file_to_read = "students.csv"
try:
    with open(csv_file_to_read, "r", newline="") as f:
        reader = csv.reader(f)
        print(f"\nContents of {csv_file_to_read}:")
        for row in reader:
            print(", ".join(row))
except FileNotFoundError:
    print(f"Error: The CSV file {csv_file_to_read} was not found.")
except IOError as e:
    print(f"Error reading CSV file: {e}")

# --- os module example ---
import os
print(f"\nCurrent working directory: {os.getcwd()}")
# print(f"Files in current directory: {os.listdir('.')}") # Be careful with this in large directories
```

### Projects/Tasks

Choose one of the following projects to practice modules, packages, and file handling:

1.  **Personal Expense Tracker:** Create a command-line application to track personal expenses. Expenses should be stored in a JSON file. Each expense entry could have a date, description, category, and amount. The application should allow users to add new expenses, view all expenses, view expenses by category, and maybe show a summary of total spending.
    *   **Detailed Steps:**
        1.  Define the structure of an expense (e.g., a dictionary: `{"date": "2024-07-26", "description": "Coffee", "category": "Food", "amount": 3.50}`).
        2.  Create a function to load expenses from a JSON file (e.g., `expenses.json`). If the file doesn't exist, return an empty list.
        3.  Create a function to save expenses (a list of dictionaries) to the JSON file.
        4.  Create functions for:
            *   `add_expense(expenses_list)`: Prompts user for expense details and appends the new expense dictionary to the list. Then, saves the updated list.
            *   `view_all_expenses(expenses_list)`: Prints all expenses in a formatted way.
            *   `view_expenses_by_category(expenses_list, category)`: Filters and prints expenses for a given category.
            *   `show_summary(expenses_list)`: Calculates and prints total expenses and maybe totals per category.
        5.  In your main script, load the expenses, then use a loop to present a menu (Add, View All, View by Category, Summary, Exit) and call the respective functions, ensuring to save changes when necessary.

2.  **User Data CSV Processor:** Write a script that reads user data from a CSV file (e.g., `users.csv` with columns like `ID,Name,Email,SignupDate`), processes this data (e.g., converts `SignupDate` strings to `datetime` objects, validates email formats), and then writes the processed data (or a summary/filtered version) to a new CSV file.
    *   **Detailed Steps:**
        1.  Create a sample `users.csv` file with some user data.
        2.  Use the `csv` module to read the `users.csv` file.
        3.  Iterate through the rows (excluding the header).
        4.  For each row:
            *   Attempt to parse the `SignupDate` string into a `datetime` object. Handle potential `ValueError` if the format is incorrect.
            *   (Optional) Perform a basic email validation (e.g., check for "@" and ".").
            *   You might want to add a new column for "Status" (e.g., "Valid", "Invalid Date").
        5.  Store the processed rows (perhaps as dictionaries or lists) in a new list.
        6.  Use the `csv` module again to write this processed data to a new CSV file (e.g., `processed_users.csv`), including the header row.

### Next Steps

Now that you can organize your code into modules and interact with files, it's time to learn how to make your programs more robust by handling unexpected situations. The next chapter, **Exception Handling and Debugging**, will teach you how to gracefully manage errors and troubleshoot your code effectively.

---

## Exception Handling and Debugging: Writing Resilient Code

No matter how carefully you write your code, errors are inevitable. A file might be missing, a user might enter invalid input, or a network connection could fail. Instead of letting your program crash abruptly, Python provides a robust mechanism for handling these runtime errors, known as **exceptions**. This chapter will teach you how to anticipate, catch, and handle these exceptions gracefully, allowing your program to continue running or exit more cleanly. We'll start with the `try...except` block, where you "try" to execute a piece of code that might raise an exception, and if it does, you "except" it and execute alternative code. You'll learn how to handle specific types of exceptions (like `FileNotFoundError`, `ValueError`, `TypeError`, `ZeroDivisionError`) and also how to catch all exceptions using a generic `except` (though this should be used cautiously). The `else` clause can be used to run code if the `try` block succeeds without raising an exception, and the `finally` clause is used for code that must always run, whether an exception occurred or not (ideal for cleanup actions like closing files or database connections). We will also cover how to **raise** your own exceptions using the `raise` keyword when your code encounters a situation that shouldn't proceed. Beyond handling errors, this chapter will introduce you to **debugging** techniques. We'll look at using `print()` statements for simple tracing and then move on to more powerful tools like Python's built-in debugger, `pdb`, and the debugging features available in modern code editors like Visual Studio Code, which allow you to set breakpoints, step through your code line by line, inspect variable values, and understand the program's execution flow.

### Core Concepts

*   **What are Exceptions?** Events that occur during the execution of a program that disrupt the normal flow of instructions.
*   **Common Built-in Exceptions:**
    *   `TypeError`: Operation or function is applied to an object of inappropriate type.
    *   `ValueError`: Function receives an argument with the correct type but an inappropriate value.
    *   `FileNotFoundError`: Trying to open a file that doesn't exist.
    *   `ZeroDivisionError`: Division or modulo by zero.
    *   `IndexError`: Sequence subscript is out of range.
    *   `KeyError`: Mapping key is not found.
    *   `AttributeError`: Attribute reference or assignment fails.
    *   `IOError` / `OSError`: I/O operation fails (e.g., disk full).
*   **The `try...except` Block:**
    ```python
    try:
        # Code that might raise an exception
    except SpecificError as e:
        # Code to handle the exception
    ```
*   **Handling Multiple Exceptions:**
    *   Multiple `except` blocks: `except Error1: ... except Error2: ...`
    *   A single `except` block with a tuple of exceptions: `except (Error1, Error2) as e: ...`
*   **The `else` Clause:** Executed if the `try` block does *not* raise an exception.
*   **The `finally` Clause:** Always executed, whether an exception was raised or not. Used for cleanup.
*   **Raising Exceptions:** Using the `raise ExceptionType("Error message")` statement to trigger an exception intentionally.
*   **Debugging Techniques:**
    *   **`print()` statements:** Simple, but effective for tracing variable values and program flow.
    *   **Python Debugger (`pdb`):**
        *   `import pdb; pdb.set_trace()` to start the debugger at a specific point in your script.
        *   Common `pdb` commands: `n` (next line), `s` (step into function), `c` (continue execution), `l` (list source code), `p variable` (print variable), `q` (quit).
    *   **IDE/Editor Debuggers:** Visual Studio Code, PyCharm, etc., offer integrated debuggers with graphical interfaces for setting breakpoints, stepping, inspecting variables, and watching expressions.
*   **Logging:** Using the `logging` module for more sophisticated and configurable reporting of events (errors, warnings, informational messages) in your application.

### Code Examples

```python
# Basic try...except
print("--- Basic try...except ---")
try:
    num = int(input("Enter a number: "))
    result = 10 / num
    print(f"10 divided by {num} is {result}")
except ValueError:
    print("Invalid input. Please enter a valid integer.")
except ZeroDivisionError:
    print("Error: Cannot divide by zero.")
print("Program continues after the try-except block.\n")

# try...except...else...finally
print("--- try...except...else...finally ---")
try:
    file = open("non_existent_file.txt", "r")
except FileNotFoundError:
    print("The file was not found.")
else:
    print("File opened successfully. Reading content:")
    print(file.read())
    file.close()
finally:
    print("This 'finally' block always executes, whether an exception occurred or not.")
    # This is a good place for cleanup, but 'with' is often better for files.
    # If file was opened in try, it might not be defined if an error occurred before assignment.
    # So, check if 'file' exists and is open before closing.
    # if 'file' in locals() and not file.closed:
    #     file.close()
print()

# Raising an exception
print("--- Raising an exception ---")
def check_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative.")
    elif age < 18:
        print("You are a minor.")
    else:
        print("You are an adult.")

try:
    check_age(25)
    check_age(-5)
except ValueError as e:
    print(f"Caught an error: {e}")
print()

# Using pdb (for demonstration, you'd typically run this in a script)
# To test this, uncomment the next two lines and run the script.
# import pdb; pdb.set_trace()
# x = 10
# y = 20
# z = x + y
# print(f"The sum of {x} and {y} is {z}")
# When you run this, the debugger will pause at pdb.set_trace().
# You can then type 'n' for next, 'p x' to print x, etc.

# Logging example
print("--- Logging ---")
import logging

# Configure basic logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

logging.debug("This is a debug message.")
logging.info("This is an info message.")
logging.warning("This is a warning message.")
logging.error("This is an error message.")
logging.critical("This is a critical message.")

def divide_logged(a, b):
    try:
        result = a / b
    except ZeroDivisionError:
        logging.error(f"Attempted to divide {a} by zero.")
        return None
    else:
        logging.info(f"Division of {a} by {b} successful.")
        return result

divide_logged(10, 2)
divide_logged(10, 0)
```

### Projects/Tasks

Choose one of the following projects to practice exception handling and debugging:

1.  **Robust File Reader with Error Reporting:** Create a script that attempts to read a file specified by the user. The script should handle various potential errors gracefully, such as the file not being found, permission issues, or the file being empty. For each error, it should log an informative message (using `print()` or the `logging` module) and perhaps prompt the user for another filename or exit gracefully.
    *   **Detailed Steps:**
        1.  Use a `while` loop to repeatedly ask the user for a filename.
        2.  Inside a `try` block, attempt to open and read the file.
        3.  Catch specific exceptions:
            *   `FileNotFoundError`: Print "File not found. Please try again."
            *   `PermissionError`: Print "Permission denied to access this file."
            *   `IsADirectoryError`: Print "The specified path is a directory, not a file."
            *   `IOError`: For other general I/O problems.
        4.  If the file is opened successfully, check if it's empty. If it is, print a message indicating that.
        5.  If it's not empty, print its content (or a summary, like the first few lines).
        6.  Use a `finally` block to ensure the file is closed if it was successfully opened, or perform other cleanup.
        7.  Break the loop if the file is read successfully or if the user chooses to quit.

2.  **Input Validator Function:** Write a function that takes user input (e.g., for age, email, or a number within a specific range) and validates it. If the input is invalid, it should raise a custom exception with a descriptive error message. Then, write code that calls this function and handles the potential custom exceptions, prompting the user to re-enter the data.
    *   **Detailed Steps:**
        1.  Define custom exception classes that inherit from `Exception` (e.g., `class InvalidAgeError(Exception): pass`, `class InvalidEmailError(Exception): pass`).
        2.  Create validation functions:
            *   `validate_age(age_str)`: Tries to convert to `int`. Checks if age is within a reasonable range (e.g., 0-120). Raises `ValueError` or `InvalidAgeError` with specific messages.
            *   `validate_email(email_str)`: Performs basic checks (e.g., contains "@", contains "." after "@"). Raises `InvalidEmailError` if checks fail.
        3.  In your main program logic, use `while` loops to keep asking for input until valid data is provided.
        4.  Inside the loop, call the validation function within a `try...except` block.
        5.  Catch the specific custom exceptions (and potentially `ValueError` for type conversion) and print the error message from the exception.
        6.  If no exception is raised, the input is valid; break the loop and proceed.

### Next Steps

With a solid understanding of exception handling, your programs will be much more robust and user-friendly. You're now ready to explore more advanced programming paradigms and techniques. The next chapter will introduce **Functional Programming and Advanced Concepts**, which will further enhance your Python toolkit.

---

## Functional Programming and Advanced Concepts: Elevating Your Python Skills

While Python is primarily known as an object-oriented language, it also incorporates many features and concepts from functional programming. This chapter will introduce you to some of these powerful tools and other advanced Python constructs that can make your code more concise, expressive, and efficient. We'll start with **lambda functions**, which are small, anonymous functions defined with the `lambda` keyword. They are often used for short, simple operations, especially when passed as arguments to other functions. You'll learn about **map()**, **filter()**, and **reduce()**, three higher-order functions that are staples of functional programming. `map()` applies a given function to each item of an iterable (like a list) and returns a map object (an iterator). `filter()` constructs an iterator from elements of an iterable for which a function returns true. `reduce()` (from the `functools` module) applies a function of two arguments cumulatively to the items of an iterable, from left to right, so as to reduce the iterable to a single value. **List comprehensions** (and their counterparts, dictionary and set comprehensions) provide a concise and readable way to create new lists (or dictionaries/sets) by applying an expression to each item in an existing iterable, optionally with a condition. We will also explore **decorators**, which are a very powerful and useful tool in Python that allow you to modify or extend the behavior of functions or methods without permanently modifying their code. They are essentially functions that wrap other functions. Finally, we'll touch on **generators** and **iterators**, which provide a memory-efficient way to work with sequences of data, especially large or infinite ones, by producing items one at a time and only when needed (lazy evaluation).

### Core Concepts

*   **Lambda Functions:**
    *   Small, anonymous functions: `lambda arguments: expression`.
    *   Can have any number of arguments but only one expression.
    *   Often used with `map()`, `filter()`, or as a short function for a short period.
*   **`map(function, iterable)`:**
    *   Applies `function` to every item in `iterable` and returns an iterator.
    *   Example: `list(map(lambda x: x**2, [1, 2, 3]))` results in `[1, 4, 9]`.
*   **`filter(function, iterable)`:**
    *   Constructs an iterator from elements of `iterable` for which `function` returns `True`.
    *   Example: `list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4]))` results in `[2, 4]`.
*   **`functools.reduce(function, iterable)`:**
    *   Applies a function of two arguments cumulatively to the items of an iterable, from left to right, to reduce the iterable to a single value.
    *   Example: `from functools import reduce; reduce(lambda x, y: x + y, [1, 2, 3, 4])` results in `10`.
*   **List/Dict/Set Comprehensions:**
    *   Concise syntax for creating new sequences.
    *   List: `[expression for item in iterable if condition]`
    *   Dict: `{key_expression: value_expression for item in iterable if condition}`
    *   Set: `{expression for item in iterable if condition}`
*   **Decorators:**
    *   Functions that take another function as an argument (the decorated function) and return a new function, usually extending or modifying the behavior of the original function.
    *   Defined using the `@decorator_name` syntax above the function definition.
    *   Often implemented using nested functions and `*args`, `**kwargs`.
*   **Generators and the `yield` Keyword:**
    *   Generators are functions that return an iterator (a generator iterator).
    *   They use the `yield` keyword to produce a series of values over time, pausing the function's execution between yields and remembering its state.
    *   Memory-efficient for large datasets as they generate values on demand (lazy evaluation).
*   **`*args` and `**kwargs`:**
    *   `*args`: Allows a function to accept a variable number of positional arguments (collected into a tuple).
    *   `**kwargs`: Allows a function to accept a variable number of keyword arguments (collected into a dictionary).

### Code Examples

```python
# Lambda functions
print("--- Lambda Functions ---")
square = lambda x: x**2
print(f"Square of 5: {square(5)}")

add = lambda x, y: x + y
print(f"Sum of 3 and 7: {add(3, 7)}")

# map()
print("\n--- map() ---")
numbers = [1, 2, 3, 4, 5]
squared_numbers_map = list(map(lambda x: x**2, numbers))
print(f"Original numbers: {numbers}")
print(f"Squared using map(): {squared_numbers_map}")

# Using map() with a named function
def to_uppercase(s):
    return s.upper()

names = ["alice", "bob", "charlie"]
uppercase_names = list(map(to_uppercase, names))
print(f"Uppercase names: {uppercase_names}")

# filter()
print("\n--- filter() ---")
even_numbers_filter = list(filter(lambda x: x % 2 == 0, numbers))
print(f"Even numbers using filter(): {even_numbers_filter}")

long_names = list(filter(lambda name: len(name) > 4, names))
print(f"Names longer than 4 characters: {long_names}")

# reduce()
print("\n--- reduce() ---")
from functools import reduce

sum_of_numbers = reduce(lambda x, y: x + y, numbers)
print(f"Sum of numbers using reduce(): {sum_of_numbers}")

product_of_numbers = reduce(lambda x, y: x * y, numbers)
print(f"Product of numbers using reduce(): {product_of_numbers}")

# List comprehensions
print("\n--- List Comprehensions ---")
squared_numbers_comp = [x**2 for x in numbers]
print(f"Squared using list comprehension: {squared_numbers_comp}")

even_numbers_comp = [x for x in numbers if x % 2 == 0]
print(f"Even numbers using list comprehension: {even_numbers_comp}")

# Dict comprehensions
name_lengths_comp = {name: len(name) for name in names}
print(f"Name lengths (dict comprehension): {name_lengths_comp}")

# Set comprehensions
unique_chars_comp = {char for name in names for char in name if char not in 'aeiou'}
print(f"Unique consonants in names (set comprehension): {unique_chars_comp}")

# Decorators
print("\n--- Decorators ---")
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()

# Decorator with arguments
def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper_repeat
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("David")

# Generators
print("\n--- Generators ---")
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
print(f"First yield: {next(gen)}")
print(f"Second yield: {next(gen)}")
print(f"Third yield: {next(gen)}")
# next(gen) would raise StopIteration

def countdown_generator(n):
    while n > 0:
        yield n
        n -= 1
    yield "Blast off!"

for i in countdown_generator(5):
    print(i, end=" ")
print() # for newline

# *args and **kwargs
print("\n--- *args and **kwargs ---")
def print_all_args(*args, **kwargs):
    print("Positional arguments (*args):")
    for arg in args:
        print(f"  {arg}")
    print("Keyword arguments (**kwargs):")
    for key, value in kwargs.items():
        print(f"  {key}: {value}")

print_all_args(1, "two", 3.0, name="Alice", city="Wonderland")
```

### Projects/Tasks

Choose one of the following projects to apply these advanced concepts:

1.  **Data Transformation Pipeline:** Create a script that processes a list of dictionaries representing data (e.g., products with `name`, `price`, `category`). Use `map()` to apply transformations (e.g., convert price to a different currency, standardize names), `filter()` to select specific items (e.g., products in a certain category or above a certain price), and `reduce()` (or a loop with comprehensions) to calculate aggregates (e.g., total price of selected items, average price).
    *   **Detailed Steps:**
        1.  Define a sample list of product dictionaries.
        2.  Use `map()` with a lambda or named function to, for example, increase all prices by 10% or add a new key like `formatted_price`.
        3.  Use `filter()` to select only products belonging to a specific category (e.g., "Electronics").
        4.  Use `reduce()` to calculate the total cost of all (filtered) products.
        5.  Alternatively, use list comprehensions to achieve similar transformations and filtering.
        6.  Print the results at each stage to show the pipeline.

2.  **Simple Logging Decorator:** Implement a decorator that logs the call of a function (its name and arguments) and its return value or any exception it raises. Apply this decorator to a few sample functions (e.g., one that adds two numbers, one that divides two numbers, one that processes a string).
    *   **Detailed Steps:**
        1.  Define a decorator, say `log_function_call`.
        2.  The inner `wrapper` function should:
            *   Print information about the function being called (e.g., `f"Calling {func.__name__} with args: {args}, kwargs: {kwargs}"`).
            *   Use a `try...except` block to call the original function `func(*args, **kwargs)`.
            *   If successful, print the return value.
            *   If an exception occurs, print the exception information.
            *   Return the result of the function call (or re-raise the exception if desired).
        3.  Define at least two sample functions (e.g., `add(a, b)`, `divide(a, b)`, `process_text(text)`).
        4.  Apply your `@log_function_call` decorator to these functions.
        5.  Call the decorated functions and observe the logging output.

### Next Steps

You've now explored some of Python's more sophisticated features. With this knowledge, you're well-prepared to dive into specialized, high-demand application areas. The next chapter will introduce you to **Web Scraping Fundamentals**, a powerful technique for extracting data from websites.

---

## Web Scraping Fundamentals: Extracting Data from the Web

Web scraping is the process of automatically extracting data from websites. It's a powerful technique for gathering information that is publicly available but not provided through a convenient API. This chapter will equip you with the fundamental skills and tools needed to perform web scraping ethically and effectively. We'll begin by understanding the basics of how web pages are structured, focusing on **HTML (HyperText Markup Language)**. You'll learn how to inspect the HTML of a webpage using your browser's developer tools to identify the specific elements and data you want to extract. The primary tool we'll use is the **Requests** library, which allows us to send HTTP requests to web servers and download the HTML content of pages. Once we have the HTML, we'll use **Beautiful Soup**, a popular Python library, to parse this raw HTML and navigate its structure. Beautiful Soup makes it easy to search for elements by their tags, attributes, CSS classes, and IDs, and to extract the data contained within them. We'll cover methods like `find()`, `find_all()`, and CSS selectors. While Beautiful Soup is excellent for static content, many modern websites load data dynamically using JavaScript. For such cases, we'll introduce **Selenium**, a browser automation tool that can control a web browser programmatically, interact with elements, click buttons, fill forms, and wait for content to load before scraping it. Crucially, we will also discuss the **ethics and legality of web scraping**, emphasizing the importance of checking a website's `robots.txt` file, respecting `Crawl-Delay` directives, identifying your bot with a proper `User-Agent` string, and avoiding overly aggressive requests that could harm the website's performance.

### Core Concepts

*   **HTML Basics:** Understanding HTML tags (e.g., `<p>`, `<div>`, `<span>`, `<a>`, `<h1>` to `<h6>`, `<table>`, `<tr>`, `<td>`), attributes (e.g., `class`, `id`, `href`), and the Document Object Model (DOM) tree structure.
*   **Inspecting Web Pages:** Using browser developer tools (usually accessed by right-clicking on a page and selecting "Inspect" or "Inspect Element") to find the HTML elements corresponding to the data you want to scrape.
*   **HTTP Requests and Responses:**
    *   GET requests to fetch web page content.
    *   Understanding status codes (200 OK, 404 Not Found, etc.).
    *   Headers, particularly the `User-Agent`.
*   **The `requests` Library:**
    *   `import requests`
    *   `response = requests.get(url)`
    *   `response.status_code`
    *   `response.text` (content as string)
    *   `response.content` (content as bytes)
*   **Parsing HTML with Beautiful Soup (`bs4`):**
    *   `from bs4 import BeautifulSoup`
    *   `soup = BeautifulSoup(html_content, 'html.parser')` (or `'lxml'` if installed)
    *   Navigating the parse tree: `soup.title`, `soup.body`, `soup.find('tag')`, `soup.find_all('tag')`.
    *   Searching by attributes: `soup.find(id='main')`, `soup.find_all(class_='article')`.
    *   CSS Selectors: `soup.select('div.content > p')` (very powerful).
    *   Extracting data: `.text`, `.get_text()`, `tag['attribute_name']` (e.g., `link['href']`).
*   **Handling Dynamic Content with Selenium:**
    *   Used for pages that load content using JavaScript after the initial page load.
    *   Requires a WebDriver (e.g., ChromeDriver, GeckoDriver).
    *   `from selenium import webdriver`
    *   `driver = webdriver.Chrome()`
    *   `driver.get(url)`
    *   Finding elements: `driver.find_element(By.ID, "some_id")`, `driver.find_elements(By.CLASS_NAME, "some_class")`.
    *   Interacting: `element.click()`, `element.send_keys("text")`.
    *   Waiting for elements: `WebDriverWait` and `expected_conditions`.
    *   `driver.page_source` to get HTML after JS execution.
    *   `driver.quit()` to close the browser.
*   **Ethical and Legal Considerations:**
    *   Check `website.com/robots.txt`.
    *   Respect `Crawl-Delay`.
    *   Set a custom `User-Agent` to identify your scraper.
    *   Don't hammer the server with too many requests; add delays (`time.sleep()`).
    *   Be aware of copyright and terms of service of the website.
    *   Scrape only publicly available data.

### Code Examples

```python
# --- Note: For these examples to run, you might need to install libraries ---
# pip install requests
# pip install beautifulsoup4
# pip install lxml (optional parser for BeautifulSoup)
# pip install selenium
# For Selenium, you also need to download the appropriate WebDriver for your browser
# and ensure it's in your system's PATH or specify its location.

import requests
from bs4 import BeautifulSoup
import time
import json # For storing scraped data

# --- Basic scraping with requests and BeautifulSoup ---
print("--- Basic Scraping with Requests & BeautifulSoup ---")
# Example: Scraping quotes from http://quotes.toscrape.com/ (a site designed for scraping)
url = "http://quotes.toscrape.com/"
try:
    response = requests.get(url)
    response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)
    soup = BeautifulSoup(response.text, 'html.parser') # or 'lxml'

    # Find all quote containers (inspect the page to find the right class/tag)
    quotes = soup.find_all('div', class_='quote')

    scraped_quotes = []
    for quote_element in quotes:
        text = quote_element.find('span', class_='text').get_text(strip=True)
        author = quote_element.find('small', class_='author').get_text(strip=True)
        # tags = [tag.get_text(strip=True) for tag in quote_element.find_all('a', class_='tag')]
        scraped_quotes.append({"text": text, "author": author})
        print(f"Quote: {text} - {author}")

    # Store scraped data in a JSON file
    with open("quotes.json", "w", encoding="utf-8") as f:
        json.dump(scraped_quotes, f, ensure_ascii=False, indent=4)
    print(f"\nScraped {len(scraped_quotes)} quotes and saved to quotes.json")

except requests.exceptions.RequestException as e:
    print(f"Error fetching URL: {e}")
except Exception as e:
    print(f"An error occurred during scraping: {e}")

print("\n" + "="*50 + "\n")

# --- Example with Selenium for dynamic content ---
# Note: This requires a WebDriver. The following is a conceptual example.
# You might need to adjust based on your browser and WebDriver setup.
print("--- Conceptual Selenium Example ---")
# from selenium import webdriver
# from selenium.webdriver.common.by import By
# from selenium.webdriver.support.ui import WebDriverWait
# from selenium.webdriver.support import expected_conditions as EC
# from selenium.common.exceptions import TimeoutException

# # Setup ChromeDriver (ensure chromedriver is in your PATH or provide path)
# # driver = webdriver.Chrome(executable_path='/path/to/chromedriver') # If not in PATH
# # driver = webdriver.Chrome() # If chromedriver is in PATH

# try:
#     # Replace with a URL known to load content dynamically
#     dynamic_url = "https://quotes.toscrape.com/js/" # This page loads quotes via JS
#     print(f"Navigating to {dynamic_url}")
#     driver.get(dynamic_url)

#     # Wait for the quotes to be loaded (e.g., wait for an element with class 'quote' to be present)
#     # This is more robust than a fixed time.sleep()
#     wait = WebDriverWait(driver, 10) # Wait up to 10 seconds
#     wait.until(EC.presence_of_element_located((By.CLASS_NAME, 'quote')))
#     print("Quotes loaded.")

#     # Now get the page source after JS has executed
#     page_source = driver.page_source
#     soup_dynamic = BeautifulSoup(page_source, 'html.parser')

#     dynamic_quotes = soup_dynamic.find_all('div', class_='quote')
#     print(f"Found {len(dynamic_quotes)} quotes using Selenium.")
#     for quote_element in dynamic_quotes:
#         text = quote_element.find('span', class_='text').get_text(strip=True)
#         author = quote_element.find('small', class_='author').get_text(strip=True)
#         print(f"Quote: {text} - {author}")

# except TimeoutException:
#     print("Timed out waiting for page to load.")
# except Exception as e:
#     print(f"An error occurred with Selenium: {e}")
# finally:
#     if 'driver' in locals() and driver:
#         print("Closing browser.")
#         driver.quit() # Important: close the browser

print("\n" + "="*50 + "\n")

# --- Handling Sessions and Headers ---
print("--- Using Sessions and Custom Headers ---")
# Using a session object can persist parameters across requests and reuse connections
session = requests.Session()
# Set a custom User-Agent to identify your scraper
headers = {
    'User-Agent': 'MyCoolScraper/1.0 (https://mywebsite.com/bot-info; contact@mywebsite.com)'
}
session.headers.update(headers)

# Example of making a request with the session
# response_with_session = session.get("http://httpbin.org/user-agent")
# print(f"User-Agent sent with session: {response_with_session.json()['user-agent']}")

# Remember to close the session if you're done with it, though it's often not strictly
# necessary for short scripts as it will be closed when the script ends.
# session.close()
```

### Projects/Tasks

Choose one of the following projects to practice web scraping:

1.  **News Article Scraper:** Write a script that scrapes a news website (choose one that is scraper-friendly, perhaps with a dedicated section or an RSS feed that lists articles). Your script should extract the headline, publication date, a short summary (or the first paragraph), and the article URL for the latest N articles. Store this data in a structured format like a list of dictionaries, and then save it to a JSON or CSV file.
    *   **Detailed Steps:**
        1.  Identify a target news website and a section (e.g., "Latest News").
        2.  Use browser developer tools to inspect the HTML structure of article listings (e.g., each article might be in a `<div>` with a specific class).
        3.  Use `requests` to get the page content.
        4.  Use `BeautifulSoup` to parse the HTML and find all article listing elements.
        5.  For each article element, extract the headline (likely within an `<h2>` or `<h3>` tag, often an `<a>` tag), the publication date (look for `<time>` tags or specific classes), the summary (often a `<p>` tag), and the URL (from the `href` attribute of an `<a>` tag).
        6.  Store each extracted article's data as a dictionary.
        7.  Collect all dictionaries into a list.
        8.  Save the list to a JSON file (using `json.dump()`) or a CSV file (using the `csv` module).
        9.  Be mindful of pagination if you want to scrape more than just the first page.

2.  **Product Price Tracker (Basic):** Scrape an e-commerce website (again, choose one that is known to be relatively easy to scrape, or a practice site like `http://books.toscrape.com/`) for a specific product category. Extract the product name, price, and availability (e.g., "In Stock," "Out of Stock") for each product on the page. Print this information to the console or save it to a file.
    *   **Detailed Steps:**
        1.  Choose a product category page on an e-commerce site.
        2.  Inspect the HTML to understand how product information is structured (e.g., each product in a `<li>` or `<div>`).
        3.  Use `requests` and `BeautifulSoup` to fetch and parse the page.
        4.  Loop through the product elements.
        5.  For each product, extract its name, price (be careful with currency symbols and formatting, you might need to clean the string), and availability status.
        6.  Print the extracted data in a tabular format or save it to a CSV file.
        7.  (Optional extension, if feeling adventurous): If the site has pagination, modify your script to scrape multiple pages of products.

### Next Steps

Once you've mastered the fundamentals of web scraping, you'll be able to collect data from a vast array of online sources. The natural next step is to learn how to clean, analyze, and derive insights from this data. This leads us to the next major section: **Data Analytics with Python**.

---

## Data Analytics with Python: From Raw Data to Insights

Data analytics is the process of inspecting, cleansing, transforming, and modeling data with the goal of discovering useful information, informing conclusions, and supporting decision-making. Python has become the dominant language in this field, largely due to its powerful ecosystem of libraries. This chapter will introduce you to the foundational libraries for data analysis in Python: **NumPy**, **Pandas**, **Matplotlib**, and **Seaborn**. We'll start with **NumPy** (Numerical Python), which provides support for large, multi-dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays efficiently. It forms the bedrock upon which many other data science libraries are built. Next, we'll dive into **Pandas**, which is essential for data manipulation and analysis. Its primary data structures, the `Series` (1-dimensional) and `DataFrame` (2-dimensional, table-like), allow you to handle and analyze tabular data with ease. You'll learn how to load data from various sources (like CSV files, JSON, or even scraped data), clean it (handle missing values, correct data types), filter and select specific subsets, group data for aggregation, and merge different datasets. Once your data is clean and structured, you'll want to visualize it to uncover patterns and trends. **Matplotlib** is the fundamental plotting library in Python, offering a wide variety of static, animated, and interactive visualizations. **Seaborn** is built on top of Matplotlib and provides a high-level interface for drawing attractive and informative statistical graphics. By combining these tools, you'll be able to perform an end-to-end exploratory data analysis (EDA), turning raw, messy data into meaningful insights.

### Core Concepts

*   **NumPy (`numpy`):**
    *   **Arrays (`ndarray`):** The core data structure. Efficient for numerical operations.
    *   Creating arrays: `np.array()`, `np.arange()`, `np.zeros()`, `np.ones()`, `np.linspace()`.
    *   Array attributes: `shape`, `dtype`, `ndim`, `size`.
    *   Indexing and slicing: Similar to Python lists but extended to multiple dimensions.
    *   Universal Functions (ufuncs): Element-wise operations (e.g., `np.add()`, `np.multiply()`, `np.sqrt()`, `np.sin()`).
    *   Array manipulation: `reshape()`, `transpose()`, `concatenate()`, `split()`.
    *   Aggregation functions: `np.sum()`, `np.mean()`, `np.std()`, `np.min()`, `np.max()`, `np.argmax()`.
*   **Pandas (`pandas`):**
    *   **Series:** 1D labeled array, capable of holding any data type.
    *   **DataFrame:** 2D labeled data structure with columns of potentially different types. Think of it as a spreadsheet or SQL table.
    *   **Data I/O:** `pd.read_csv()`, `pd.read_json()`, `df.to_csv()`, `df.to_json()`.
    *   **Data Inspection:** `df.head()`, `df.tail()`, `df.info()`, `df.describe()`, `df.shape`, `df.columns`, `df.dtypes`.
    *   **Data Selection:**
        *   Selecting columns: `df['column_name']` or `df.column_name`.
        *   Selecting rows by label: `df.loc[]`.
        *   Selecting rows by integer position: `df.iloc[]`.
        *   Boolean indexing (filtering): `df[df['column'] > value]`.
    *   **Data Cleaning:**
        *   Handling missing data: `df.isnull().sum()`, `df.dropna()`, `df.fillna()`.
        *   Data type conversion: `df['column'].astype()`.
        *   String operations: `df['column'].str` accessor (e.g., `.str.lower()`, `.str.contains()`).
        *   Applying functions: `df.apply()`, `df.applymap()`, Series `.apply()`.
    *   **Data Manipulation:**
        *   Sorting: `df.sort_values()`.
        *   Grouping and aggregation: `df.groupby().agg()`.
        *   Merging/Joining: `pd.merge()`.
        *   Concatenating: `pd.concat()`.
        *   Pivoting tables: `df.pivot_table()`.
*   **Data Visualization with Matplotlib (`matplotlib.pyplot`):**
    *   Basic plots: `plt.plot()` (line plot), `plt.scatter()` (scatter plot), `plt.bar()` (bar plot), `plt.hist()` (histogram).
    *   Customizing plots: Labels (`plt.xlabel()`, `plt.ylabel()`, `plt.title()`), legends (`plt.legend()`), limits (`plt.xlim()`, `plt.ylim()`).
    *   Creating subplots: `plt.subplots()`.
    *   Showing plots: `plt.show()`.
*   **Statistical Visualization with Seaborn (`seaborn`):**
    *   Built-in themes and color palettes for aesthetically pleasing plots.
    *   Common plot types: `sns.histplot()` (histograms), `sns.kdeplot()` (kernel density estimate), `sns.scatterplot()`, `sns.lineplot()`, `sns.barplot()`, `sns.boxplot()` (box plots), `sns.violinplot()` (violin plots).
    *   Plotting categorical data: `sns.countplot()`, `sns.catplot()`.
    *   Visualizing relationships: `sns.pairplot()` (for pairwise relationships in a DataFrame), `sns.heatmap()` (for correlation matrices).
    *   Works seamlessly with Pandas DataFrames.
*   **Exploratory Data Analysis (EDA) Workflow:**
    1.  Formulate questions.
    2.  Load data.
    3.  Clean and preprocess data.
    4.  Analyze data (statistics, aggregations).
    5.  Visualize data to find patterns, trends, and anomalies.
    6.  Draw conclusions and iterate.

### Code Examples

```python
# --- Note: For these examples, you need to install pandas, numpy, matplotlib, seaborn ---
# pip install pandas numpy matplotlib seaborn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Set some seaborn styles for better looking plots
sns.set_theme(style="whitegrid")

# --- NumPy Basics ---
print("--- NumPy Basics ---")
arr = np.array([1, 2, 3, 4, 5])
print(f"NumPy Array: {arr}")
print(f"Shape: {arr.shape}, Data Type: {arr.dtype}")
print(f"Mean: {np.mean(arr)}, Sum: {np.sum(arr)}")

matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(f"\nMatrix:\n{matrix}")
print(f"First row: {matrix[0, :]}")
print(f"Second column: {matrix[:, 1]}")

# --- Pandas Basics ---
print("\n--- Pandas Basics ---")
# Creating a DataFrame
data = {'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],
        'Age': [25, 30, 35, 28, 22],
        'City': ['New York', 'London', 'Paris', 'Tokyo', 'Sydney'],
        'Salary': [70000, 80000, 120000, 95000, 65000]}
df = pd.DataFrame(data)
print("Original DataFrame:")
print(df)
print(f"\nDataFrame Info:")
df.info()
print(f"\nDataFrame Description:")
print(df.describe())

# Data Selection
print(f"\nAges of people:\n{df['Age']}")
print(f"\nPeople older than 28:\n{df[df['Age'] > 28]}")
print(f"\nFirst 3 rows:\n{df.head(3)}")
print(f"\nPerson at index 2 (loc):\n{df.loc[2]}")
print(f"\nPerson at index 2 (iloc):\n{df.iloc[2]}")

# Data Cleaning (example with missing values)
df_with_nan = df.copy()
df_with_nan.loc[1, 'Salary'] = np.nan
df_with_nan.loc[3, 'City'] = np.nan
print(f"\nDataFrame with NaN:\n{df_with_nan}")
print(f"\nMissing values per column:\n{df_with_nan.isnull().sum()}")
df_filled = df_with_nan.fillna({'Salary': df_with_nan['Salary'].mean(), 'City': 'Unknown'})
print(f"\nDataFrame after filling NaN:\n{df_filled}")

# Data Manipulation
print(f"\nAverage Salary by City:\n{df.groupby('City')['Salary'].mean()}")
df_sorted = df.sort_values(by='Salary', ascending=False)
print(f"\nDataFrame sorted by Salary (descending):\n{df_sorted}")

# --- Matplotlib Basics ---
print("\n--- Matplotlib Basics ---")
# Line plot
ages = df['Age']
salaries = df['Salary']
plt.figure(figsize=(10, 5))
plt.plot(ages, salaries, marker='o')
plt.xlabel('Age')
plt.ylabel('Salary')
plt.title('Age vs Salary')
plt.grid(True)
# plt.show() # Uncomment to display the plot

# Bar plot
plt.figure(figsize=(10, 5))
plt.bar(df['Name'], df['Salary'])
plt.xlabel('Name')
plt.ylabel('Salary')
plt.title('Salary by Person')
# plt.show()

# --- Seaborn Basics ---
print("\n--- Seaborn Basics ---")
# Scatter plot
plt.figure(figsize=(10, 6))
sns.scatterplot(x='Age', y='Salary', hue='City', data=df, s=100) # s is marker size
plt.title('Age vs Salary by City (Seaborn)')
# plt.show()

# Histogram
plt.figure(figsize=(10, 6))
sns.histplot(df['Age'], bins=5, kde=True)
plt.title('Distribution of Ages (Seaborn)')
# plt.show()

# Box plot
plt.figure(figsize=(10, 6))
sns.boxplot(x='City', y='Salary', data=df)
plt.title('Salary Distribution by City (Seaborn)')
# plt.show()

# Pairplot (useful for EDA on multiple numerical columns)
# For a larger dataset, this would be very informative
# sns.pairplot(df[['Age', 'Salary']])
# plt.suptitle('Pairplot of Age and Salary', y=1.02)
# plt.show()

# To display plots if running in an environment that supports it (like Jupyter)
# or if you have a GUI backend configured for matplotlib.
# For scripts that save to file, you'd use plt.savefig('filename.png')
# instead of plt.show().
# If you are running this in a standard script environment without a GUI,
# you might need to set a non-interactive backend for matplotlib before importing pyplot:
# import matplotlib
# matplotlib.use('Agg') # Use a non-interactive backend
# import matplotlib.pyplot as plt
# Then, use plt.savefig('my_plot.png') instead of plt.show()
```

### Projects/Tasks

Choose one of the following projects to perform data analysis:

1.  **Exploratory Data Analysis (EDA) on a Dataset:** Find a publicly available dataset of interest (e.g., from Kaggle, UCI Machine Learning Repository, or government open data portals). A good starting point could be a dataset about movies, Titanic passengers, Iris flowers, or COVID-19 cases. Perform a thorough EDA:
    *   **Detailed Steps:**
        1.  **Load the Data:** Use Pandas to load the dataset (e.g., from a CSV file).
        2.  **Initial Inspection:** Use `df.head()`, `df.info()`, `df.describe()`, `df.shape`, `df.columns` to understand the dataset's structure, data types, and basic statistics.
        3.  **Data Cleaning:**
            *   Check for and handle missing values (`df.isnull().sum()`, `df.dropna()`, `df.fillna()`).
            *   Convert data types if necessary (e.g., string dates to datetime objects, numeric columns stored as strings).
            *   Identify and potentially handle outliers.
        4.  **Univariate Analysis:** Analyze individual columns.
            *   For numerical columns: Plot histograms, boxplots to understand distributions, central tendencies, and spreads.
            *   For categorical columns: Plot bar charts or count plots to see frequency of categories.
        5.  **Bivariate/Multivariate Analysis:** Explore relationships between variables.
            *   Numerical vs. Numerical: Use scatter plots, correlation matrices (visualized with heatmaps).
            *   Categorical vs. Numerical: Use boxplots, violin plots, or bar plots showing means/medians.
            *   Categorical vs. Categorical: Use stacked bar charts or contingency tables.
        6.  **Ask and Answer Questions:** Formulate specific questions based on your initial findings and use data manipulation and visualization to answer them (e.g., "What factors seem to correlate most with survival on the Titanic?" or "How have movie ratings changed over the years?").
        7.  **Summarize Findings:** Write a brief summary of your key insights from the EDA.

2.  **Data Aggregation and Reporting:** Using a dataset (could be the same as in task 1 or a different one, perhaps sales data), perform specific aggregations and create a summary report with visualizations.
    *   **Detailed Steps:**
        1.  **Load and Clean Data:** As in the EDA task.
        2.  **Specific Aggregations:**
            *   Group data by one or more categorical columns and calculate summary statistics (sum, mean, count, etc.) for numerical columns. For example, if it's sales data, group by `Region` and `Product Category` to find total sales and average sales per transaction.
            *   Use `df.groupby().agg()` to perform multiple aggregations at once.
            *   Create pivot tables to reorganize and summarize data.
        3.  **Visualizations for Reporting:**
            *   Create bar charts to compare aggregated values across different categories (e.g., total sales by region).
            *   Use line charts to show trends over time if a date column is available (e.g., monthly sales).
            *   Use pie charts (sparingly, as they can be misleading) to show proportions of a whole.
        4.  **Generate a Report:** Compile your key findings and the most insightful visualizations into a concise report. This could be a Jupyter Notebook with Markdown explanations or a simple text document with saved image files.

### Next Steps

With a solid foundation in data analytics, you can now extract meaningful insights from complex datasets. The final core area we'll explore is **Workflow Automation**, where you'll learn to apply your Python skills to automate repetitive tasks and streamline various processes.

---

## Workflow Automation: Streamlining Your Tasks with Python

Python's simplicity and vast library ecosystem make it an excellent tool for automating a wide range of repetitive and time-consuming tasks, thereby boosting productivity and reducing the potential for human error. This chapter will focus on practical automation techniques you can apply in your daily work or personal projects. We'll start by automating interactions with files and folders on your operating system using the `os` and `shutil` modules. You'll learn how to programmatically create, move, copy, rename, and delete files and directories, which is incredibly useful for organizing large numbers of files or batch processing. Next, we'll explore automating tasks related to common office file formats. You'll learn how to read from and write to **CSV files** (as previously touched upon, but with a focus on automation) and, more powerfully, how to manipulate **Excel spreadsheets** using libraries like `openpyxl` or `pandas`. This can include updating cell values, formatting sheets, creating new sheets, and extracting data from multiple Excel files automatically. We'll also cover sending **emails automatically** using Python's built-in `smtplib` and `email` modules, which can be used for sending notifications, reports, or personalized bulk emails. Another key aspect of workflow automation is **scheduling** your Python scripts to run at specific times or intervals. We'll discuss how to use tools like the built-in `schedule` library for simple scheduling or integrate with system-level schedulers like `cron` (on Linux/macOS) or Task Scheduler (on Windows). By combining these techniques, you can build powerful automation workflows that save you significant time and effort.

### Core Concepts

*   **File and Directory Automation (`os`, `shutil`, `glob`):**
    *   `os.getcwd()`, `os.chdir(path)`: Get and change current working directory.
    *   `os.listdir(path)`: List files and directories in a path.
    *   `os.mkdir(path)`, `os.makedirs(path)`: Create single or nested directories.
    *   `os.remove(path)`, `os.rmdir(path)`: Remove a file or an empty directory.
    *   `shutil.copy(src, dst)`, `shutil.copy2(src, dst)` (preserves metadata): Copy files.
    *   `shutil.copytree(src, dst)`: Copy entire directory tree.
    *   `shutil.move(src, dst)`: Move files or directories (can also rename).
    *   `os.rename(src, dst)`: Rename a file or directory.
    *   `os.path.join(path, *paths)`: Intelligently join path components.
    *   `os.path.exists(path)`, `os.path.isfile(path)`, `os.path.isdir(path)`: Check path status.
    *   `glob.glob(pattern)`: Find all pathnames matching a specified pattern (e.g., `glob.glob("*.txt")`).
*   **Excel Automation (`openpyxl`):**
    *   `pip install openpyxl`
    *   Loading a workbook: `from openpyxl import load_workbook; wb = load_workbook('filename.xlsx')`.
    *   Creating a new workbook: `from openpyxl import Workbook; wb = Workbook()`.
    *   Selecting a worksheet: `ws = wb.active` or `ws = wb['SheetName']`.
    *   Accessing cells: `ws['A1']`, `ws.cell(row=1, column=1)`.
    *   Reading cell values: `cell.value`.
    *   Writing to cells: `cell.value = 'New Value'`.
    *   Iterating through rows/columns: `for row in ws.iter_rows(): ...`
    *   Appending data: `ws.append([1, 2, 3])`.
    *   Saving a workbook: `wb.save('filename.xlsx')`.
*   **Email Automation (`smtplib`, `email`):**
    *   `import smtplib`
    *   `from email.mime.text import MIMEText`
    *   `from email.mime.multipart import MIMEMultipart` (for emails with attachments)
    *   `from email.mime.application import MIMEApplication` (for attachments)
    *   Setting up an SMTP connection: `with smtplib.SMTP('smtp.example.com', 587) as server:`
    *   Starting TLS for security: `server.starttls()`
    *   Logging in: `server.login('your_email@example.com', 'your_password')`
    *   Creating a message: `msg = MIMEMultipart(); msg['From'] = ...; msg['To'] = ...; msg['Subject'] = ...`
    *   Attaching body: `msg.attach(MIMEText(body, 'plain'))` or `'html'`
    *   Sending the email: `server.send_message(msg)`
*   **Scheduling Scripts:**
    *   **`schedule` library:** `pip install schedule`
        *   `import schedule`
        *   `schedule.every(10).minutes.do(job)`
        *   `schedule.every().day.at("10:30").do(job)`
        *   `while True: schedule.run_pending(); time.sleep(1)`
    *   **`cron` (Linux/macOS):** Use `crontab -e` to edit cron jobs. Format: `minute hour day-of-month month day-of-week command-to-run`.
    *   **Task Scheduler (Windows):** Use the GUI to create basic tasks or `schtasks` command-line tool.
*   **Running System Commands (`subprocess`):**
    *   `import subprocess`
    *   `subprocess.run(["ls", "-l"])` (recommended)
    *   `subprocess.Popen(["your_command", "arg1", "arg2"])` (for more complex scenarios)
*   **Interacting with APIs (`requests`):** Many automation tasks involve interacting with web APIs to fetch or send data, as covered in the web scraping chapter's context of making HTTP requests.

### Code Examples

```python
# --- Note: For these examples, you might need to install libraries ---
# pip install openpyxl
# pip install schedule
# pip install Pillow (for image manipulation examples, if any)

import os
import shutil
import glob
import time
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
# For openpyxl, ensure you have it installed: pip install openpyxl
# import openpyxl

# --- File and Directory Automation ---
print("--- File and Directory Automation ---")
# Create a directory for our automation tasks
automation_dir = "automation_workspace"
if not os.path.exists(automation_dir):
    os.makedirs(automation_dir)
    print(f"Created directory: {automation_dir}")

# Create some dummy files
for i in range(3):
    with open(os.path.join(automation_dir, f"file_{i+1}.txt"), "w") as f:
        f.write(f"This is content of file {i+1}.\n")
print("Created dummy text files.")

# List files in the directory
print(f"\nFiles in {automation_dir}:")
for item in os.listdir(automation_dir):
    print(f"  - {item}")

# Find all .txt files using glob
txt_files = glob.glob(os.path.join(automation_dir, "*.txt"))
print(f"\nFound .txt files using glob: {txt_files}")

# Create a subdirectory and move a file
sub_dir = os.path.join(automation_dir, "sub_folder")
os.makedirs(sub_dir, exist_ok=True) # exist_ok=True prevents error if dir exists
source_file = os.path.join(automation_dir, "file_1.txt")
destination_file = os.path.join(sub_dir, "moved_file_1.txt")
if os.path.exists(source_file):
    shutil.move(source_file, destination_file)
    print(f"\nMoved {source_file} to {destination_file}")
else:
    print(f"\n{source_file} not found, cannot move.")

# Copy a file
source_to_copy = os.path.join(automation_dir, "file_2.txt")
destination_copy = os.path.join(sub_dir, "copied_file_2.txt")
if os.path.exists(source_to_copy):
    shutil.copy2(source_to_copy, destination_copy) # copy2 preserves metadata
    print(f"Copied {source_to_copy} to {destination_copy}")
else:
    print(f"\n{source_to_copy} not found, cannot copy.")

print(f"\nContents of sub_folder {sub_dir}:")
for item in os.listdir(sub_dir):
    print(f"  - {item}")

# Clean up the created directory and its contents (use with caution!)
# shutil.rmtree(automation_dir)
# print(f"\nCleaned up {automation_dir}")


# --- Excel Automation (Conceptual - requires openpyxl) ---
print("\n--- Excel Automation (Conceptual with openpyxl) ---")
# Ensure you have openpyxl installed: pip install openpyxl
# try:
#     from openpyxl import Workbook, load_workbook

#     # Creating a new Excel file
#     wb_new = Workbook()
#     ws_new = wb_new.active
#     ws_new.title = "SalesData"
#     ws_new.append(["Product", "Q1_Sales", "Q2_Sales"])
#     ws_new.append(["Apples", 100, 120])
#     ws_new.append(["Oranges", 150, 130])
#     new_excel_file = "sales_report.xlsx"
#     wb_new.save(new_excel_file)
#     print(f"Created new Excel file: {new_excel_file}")

#     # Reading from an Excel file
#     wb_read = load_workbook(filename=new_excel_file)
#     ws_read = wb_read["SalesData"]
#     print(f"Reading from {new_excel_file}:")
#     for row in ws_read.iter_rows(values_only=True):
#         print(row)
    
#     # Modifying an existing Excel file
#     ws_read['C3'] = 135 # Update Q2_Sales for Oranges
#     ws_read.append(["Bananas", 80, 90]) # Add a new row
#     wb_read.save(new_excel_file) # Save changes
#     print(f"Modified and saved {new_excel_file}")

# except ImportError:
#     print("openpyxl library not found. Please install it using 'pip install openpyxl' to run this example.")
# except Exception as e:
#     print(f"An error occurred during Excel automation: {e}")


# --- Email Automation (Conceptual - requires SMTP server details) ---
print("\n--- Email Automation (Conceptual) ---")
# IMPORTANT: Replace placeholder values with actual SMTP server details and credentials.
# For Gmail, you might need to enable "Less secure app access" or use an App Password.
# DO NOT hard-code credentials in production scripts; use environment variables or config files.
def send_email_notification(subject, body, to_email, from_email, app_password, smtp_server, smtp_port):
    try:
        msg = MIMEMultipart()
        msg['From'] = from_email
        msg['To'] = to_email
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))

        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()  # Secure the connection
            server.login(from_email, app_password)
            server.send_message(msg)
        print(f"Email sent successfully to {to_email}")
    except Exception as e:
        print(f"Failed to send email: {e}")

# Example usage (commented out to prevent accidental execution with placeholders):
# send_email_notification(
#     subject="Test Automation Email",
#     body="This is a test email sent from a Python script.",
#     to_email="recipient@example.com",
#     from_email="your_email@example.com",
#     app_password="your_generated_app_password", # For Gmail, etc.
#     smtp_server="smtp.gmail.com",
#     smtp_port=587
# )


# --- Scheduling with `schedule` library (Conceptual) ---
print("\n--- Scheduling with `schedule` library (Conceptual) ---")
# Ensure you have schedule installed: pip install schedule
# try:
#     import schedule
#     import time

#     def job():
#         print("I'm working on a scheduled task...")
#         # In a real scenario, this function would contain your automation logic
#         # e.g., scrape a website, process a file, send an email.

#     # Schedule the job to run every 10 seconds
#     schedule.every(10).seconds.do(job)
#     # Schedule to run daily at a specific time
#     # schedule.every().day.at("10:30").do(job)

#     print("Scheduler started. Press Ctrl+C to exit.")
#     while True:
#         schedule.run_pending()
#         time.sleep(1)
#         # To prevent this from running forever in a real script, you might want a condition to break

# except ImportError:
#     print("schedule library not found. Please install it using 'pip install schedule'.")
# except KeyboardInterrupt:
#     print("\nScheduler stopped.")
```

### Projects/Tasks

Choose one of the following projects to implement workflow automation:

1.  **Automated File Organizer:** Create a Python script that monitors a specific "Downloads" folder (or any folder you choose). When new files are added to this folder, the script should automatically sort them into subdirectories based on their file extension (e.g., all `.jpg` and `.png` files go into an "Images" folder, all `.pdf` files into a "Documents" folder, all `.zip` files into an "Archives" folder, etc.).
    *   **Detailed Steps:**
        1.  Define the source folder to monitor and a mapping of file extensions to destination subfolder names (e.g., `{'Images': ['.jpg', '.png', '.gif'], 'Documents': ['.pdf', '.docx', '.txt']}`).
        2.  Use `os.listdir()` or `glob.glob()` periodically to get a list of files in the source folder.
        3.  For each file, check its extension (using `os.path.splitext()`).
        4.  If the extension matches one of your defined categories, create the corresponding subfolder in the source directory if it doesn't already exist (`os.makedirs(exist_ok=True)`).
        5.  Move the file from the source folder to the appropriate subfolder using `shutil.move()`.
        6.  To make this a continuously running monitor, you can put the logic in a `while True` loop with a `time.sleep()` interval (e.g., check every 60 seconds). For a more robust solution, you might explore libraries like `watchdog`.

2.  **Automated Excel Report Generator:** Suppose you have multiple CSV files, each containing daily sales data for different products or regions. Write a Python script that:
    *   Reads all CSV files from a specified directory.
    *   Combines the data from all CSV files into a single Pandas DataFrame.
    *   Performs some aggregations (e.g., total sales per product/region, average sales, etc.).
    *   Generates a summary report of these aggregations.
    *   Saves this summary report into a new, well-formatted Excel file (perhaps with a timestamp in the filename), using `openpyxl` or `pandas`' `ExcelWriter`.
    *   (Optional) Automatically emails this generated Excel report to a specified list of recipients.
    *   **Detailed Steps:**
        1.  Identify a directory with multiple CSV files. Create some sample CSVs if needed.
        2.  Use `glob.glob("your_directory/*.csv")` to get a list of all CSV files.
        3.  Loop through this list, read each CSV into a Pandas DataFrame, and append it to a list of DataFrames.
        4.  Concatenate all DataFrames in the list into a single DataFrame using `pd.concat()`.
        5.  Use Pandas' `groupby()` and `agg()` functions to perform the required calculations.
        6.  Use `pandas.DataFrame.to_excel()` (with `openpyxl` as the engine) to save the summarized DataFrame to an Excel file. You can customize sheet names, formatting, etc., if using `openpyxl` directly.
        7.  If implementing the email part, call the email sending function (like the conceptual one provided) after the Excel file is successfully created, attaching the generated report.

### Next Steps

By mastering workflow automation, you can significantly enhance your efficiency and leverage Python to handle mundane tasks. The final chapter will touch upon **Advanced Python Topics**, preparing you for more complex applications and further exploration in your Python journey.

---

## Advanced Python Topics: Preparing for the Real World

This final chapter covers a selection of advanced Python topics and best practices that are crucial for developing robust, maintainable, and professional-grade applications. While you may not become an expert in all these areas immediately, understanding their existence and basic concepts will prepare you for real-world software development challenges and guide your continued learning. We'll start with **Testing**, a fundamental practice for ensuring your code works as expected and continues to work as it evolves. You'll be introduced to Python's built-in `unittest` framework and the popular third-party library `pytest` for writing and running automated tests for your functions and classes. Next, we'll discuss **Virtual Environments**, which are essential for managing project dependencies and avoiding conflicts between different projects that might require different versions of the same library. Tools like `venv` (built-in) and `conda` allow you to create isolated environments for each project. **Working with APIs** is another critical skill. We'll expand on the `requests` library to show how to interact with RESTful APIs to fetch data from web services, which is a common requirement in modern applications. **Introduction to Databases** will cover basic database concepts and how to interact with SQL databases from Python using libraries like `sqlite3` (for the lightweight SQLite database, which is built-in) and an Object-Relational Mapper (ORM) like **SQLAlchemy**, which allows you to interact with databases using Python objects. Finally, we'll touch upon **Basic Concurrency** using the `threading` and `multiprocessing` modules, which can help you improve the performance of I/O-bound and CPU-bound tasks respectively, by allowing your program to do multiple things at once. This chapter aims to open doors to further specialization and to equip you with a broader perspective on what Python can do.

### Core Concepts

*   **Testing Your Code:**
    *   **Why test?** To ensure correctness, facilitate changes (refactoring), and document expected behavior.
    *   **`unittest` framework (built-in):**
        *   Test cases inherit from `unittest.TestCase`.
        *   Assertion methods: `self.assertEqual()`, `self.assertTrue()`, `self.assertRaises()`, etc.
        *   Test discovery and running via the command line.
    *   **`pytest` (third-party):**
        *   `pip install pytest`
        *   Simpler syntax for writing tests (functions starting with `test_`).
        *   Powerful features like fixtures, parameterization, and plugins.
        *   Auto-discovery of tests.
*   **Virtual Environments:**
    *   **Why use them?** To isolate project dependencies, avoid version conflicts, and ensure reproducibility.
    *   **`venv` (built-in module):**
        *   Creating: `python -m venv myenv`
        *   Activating:
            *   Windows: `myenv\Scripts\activate`
            *   macOS/Linux: `source myenv/bin/activate`
        *   Deactivating: `deactivate`
    *   **`conda` (part of Anaconda/Miniconda):**
        *   Creating: `conda create --name myenv python=3.9`
        *   Activating: `conda activate myenv`
        *   Deactivating: `conda deactivate`
    *   **`pip` and `requirements.txt`:**
        *   Installing packages: `pip install package_name`
        *   Generating requirements: `pip freeze > requirements.txt`
        *   Installing from requirements: `pip install -r requirements.txt`
*   **Working with APIs (Application Programming Interfaces):**
    *   **RESTful APIs:** Common architectural style for web services.
    *   **HTTP Methods:** GET (retrieve data), POST (create data), PUT (update data), DELETE (delete data).
    *   **Status Codes:** 2xx (success), 4xx (client error), 5xx (server error).
    *   **JSON (JavaScript Object Notation):** Common data format for API requests and responses.
    *   **`requests` library for API calls:**
        *   `response = requests.get(url, params=payload)`
        *   `response = requests.post(url, json=data)`
        *   `response.json()` to parse JSON response.
        *   `response.status_code`, `response.headers`.
        *   Handling authentication (API keys, OAuth tokens often passed in headers).
*   **Introduction to Databases:**
    *   **SQL (Structured Query Language):** Standard language for relational databases.
    *   **SQLite (`sqlite3` built-in module):**
        *   Serverless, zero-configuration, file-based database.
        *   `import sqlite3`
        *   `connection = sqlite3.connect('mydatabase.db')`
        *   `cursor = connection.cursor()`
        *   `cursor.execute("SQL_QUERY")`
        *   `connection.commit()` to save changes.
        *   `connection.close()`
    *   **SQLAlchemy (ORM - Object-Relational Mapper):**
        *   `pip install SQLAlchemy`
        *   Allows interaction with databases using Python classes and objects, abstracting away raw SQL.
        *   Defines database tables as Python classes.
        *   Provides a "session" to manage database operations.
*   **Basic Concurrency:**
    *   **Why concurrency?** To improve performance for I/O-bound tasks (e.g., network requests, file operations) or CPU-bound tasks (e.g., heavy calculations).
    *   **`threading` module:**
        *   Useful for I/O-bound tasks due to Global Interpreter Lock (GIL) in CPython.
        *   `threading.Thread(target=function, args=(...))`
        *   `thread.start()`, `thread.join()`
        *   `threading.Lock()` for synchronizing access to shared resources.
    *   **`multiprocessing` module:**
        *   Bypasses GIL, suitable for CPU-bound tasks by using separate processes.
        *   `multiprocessing.Process(target=function, args=(...))`
        *   Similar API to `threading`.
    *   **`asyncio` module (for advanced asynchronous programming):** For highly concurrent I/O-bound operations using a single thread and an event loop.

### Code Examples

```python
# --- Testing with pytest ---
print("--- Testing with pytest (conceptual) ---")
# To run these tests, save them in a file named test_example.py
# and run 'pytest' from your terminal in the same directory.
# Ensure pytest is installed: pip install pytest

# File: calculator.py (to be tested)
# def add(a, b):
#     return a + b

# def divide(a, b):
#     if b == 0:
#         raise ValueError("Cannot divide by zero")
#     return a / b

# File: test_calculator.py (tests)
# import pytest
# from calculator import add, divide

# def test_add_positive_numbers():
#     assert add(2, 3) == 5

# def test_add_negative_numbers():
#     assert add(-2, -3) == -5

# def test_add_zero():
#     assert add(5, 0) == 5

# def test_divide_positive_numbers():
#     assert divide(10, 2) == 5

# def test_divide_by_zero():
#     with pytest.raises(ValueError):
#         divide(10, 0)

# --- Virtual Environments (conceptual, command-line examples) ---
print("\n--- Virtual Environments (conceptual) ---")
print("# Create a virtual environment named 'myproject_env'")
print("python -m venv myproject_env")
print("\n# Activate the environment")
print("# On Windows")
print("myproject_env\\Scripts\\activate")
print("# On macOS/Linux")
print("source myproject_env/bin/activate")
print("\n# Install packages (e.g., requests)")
print("pip install requests")
print("\n# Save dependencies to requirements.txt")
print("pip freeze > requirements.txt")
print("\n# Deactivate the environment")
print("deactivate")
print("\n# To recreate the environment elsewhere:")
print("# python -m venv myproject_env")
print("# source myproject_env/bin/activate (or activate on Windows)")
print("# pip install -r requirements.txt")

# --- Working with APIs (using requests) ---
print("\n--- Working with APIs (using requests) ---")
import requests
import json

# Example: Getting a random joke from JokeAPI
api_url = "https://v2.jokeapi.dev/joke/Any?safe-mode"

try:
    response = requests.get(api_url)
    response.raise_for_status()  # Raises an HTTPError for bad responses (4XX or 5XX)
    
    if response.headers.get('Content-Type') == 'application/json':
        joke_data = response.json()
        print("Successfully fetched a joke:")
        if joke_data.get("type") == "single":
            print(f"Joke: {joke_data.get('joke')}")
        elif joke_data.get("type") == "twopart":
            print(f"Setup: {joke_data.get('setup')}")
            print(f"Delivery: {joke_data.get('delivery')}")
    else:
        print("Response was not in JSON format.")
        
except requests.exceptions.HTTPError as http_err:
    print(f"HTTP error occurred: {http_err}")
except requests.exceptions.RequestException as req_err:
    print(f"Request error occurred: {req_err}")
except json.JSONDecodeError:
    print("Error decoding JSON from response.")

# --- Introduction to Databases (SQLite example) ---
print("\n--- Introduction to Databases (SQLite example) ---")
import sqlite3

# Connect to a database (or create one if it doesn't exist)
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Create a table
cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT NOT NULL UNIQUE
    )
''')
print("Table 'users' created or already exists.")

# Insert some data
try:
    cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('Alice', 'alice@example.com'))
    cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", ('Bob', 'bob@example.com'))
    conn.commit() # Save the changes
    print("Inserted data into 'users' table.")
except sqlite3.IntegrityError as e:
    print(f"Error inserting data: {e}") # Likely due to UNIQUE constraint on email

# Query data
print("\nQuerying data from 'users' table:")
cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(f"ID: {row[0]}, Name: {row[1]}, Email: {row[2]}")

# Update data
cursor.execute("UPDATE users SET name = ? WHERE name = ?", ('Alice Smith', 'Alice'))
conn.commit()
print("\nUpdated Alice's name.")

# Query again to see the update
print("\nData after update:")
cursor.execute("SELECT * FROM users WHERE name LIKE 'Alice%'")
updated_row = cursor.fetchone()
if updated_row:
    print(f"ID: {updated_row[0]}, Name: {updated_row[1]}, Email: {updated_row[2]}")

# Close the connection
conn.close()
print("\nClosed database connection.")

# --- Basic Concurrency (Threading example) ---
print("\n--- Basic Concurrency (Threading example) ---")
import threading
import time

def print_numbers(thread_name):
    """A simple function that prints numbers with a delay."""
    for i in range(5):
        time.sleep(1)
        print(f"{thread_name}: {i}")

# Create two threads
thread1 = threading.Thread(target=print_numbers, args=("Thread-1",))
thread2 = threading.Thread(target=print_numbers, args=("Thread-2",))

# Start the threads
thread1.start()
thread2.start()

# Wait for both threads to complete
thread1.join()
thread2.join()

print("Both threads have finished execution.")
```

### Projects/Tasks

Choose one of the following projects to explore these advanced topics:

1.  **Test-Driven Development (TDD) Mini-Project:** Pick a small, well-defined problem (e.g., a function that checks if a string is a palindrome, a simple calculator class, or a function that validates user input according to specific rules). Try to implement it using a Test-Driven Development approach:
    *   **Detailed Steps:**
        1.  Set up a project with a virtual environment.
        2.  Install `pytest`.
        3.  Write a failing test case for a small piece of functionality.
        4.  Run `pytest` to confirm the test fails.
        5.  Write the minimal amount of production code required to make the test pass.
        6.  Run `pytest` again to confirm the test now passes.
        7.  Refactor your code (if needed) while ensuring the test still passes.
        8.  Repeat this cycle (Red-Green-Refactor) until all desired functionality is implemented and tested.
        9.  Aim for good test coverage of your logic.

2.  **Simple Data Persistence Application:** Extend one of your previous projects (e.g., the Contact Book, Expense Tracker, or To-Do List) to store its data in an SQLite database instead of (or in addition to) JSON/CSV files.
    *   **Detailed Steps:**
        1.  Design a simple database schema (tables and their columns) for your application's data.
        2.  Use the `sqlite3` module to create the database and tables when your application first runs (if they don't exist).
        3.  Modify your existing functions (e.g., `add_contact`, `add_expense`, `add_task`) to insert new records into the database using parameterized queries.
        4.  Modify functions that retrieve data (e.g., `view_all_contacts`, `get_expenses_by_category`) to fetch data from the database.
        5.  Implement functions to update and delete records if your application requires that functionality.
        6.  Ensure you handle database connections properly (open, use, close, or use context managers if available for your chosen method).
        7.  (Optional, more advanced): Try to refactor your database interaction logic to use SQLAlchemy for an ORM approach.

### Final Words and Continued Learning

Congratulations on completing this comprehensive Python study plan! You've journeyed from the very basics of programming to advanced topics like automation, web scraping, data analytics, and software development best practices. Remember that learning to code is a continuous process. The most important next step is to **keep building**. Work on personal projects that interest you, contribute to open-source projects, and don't be afraid to experiment. The Python community is vast and welcoming; engage with it through forums, meetups, and conferences. Explore specialized libraries and frameworks that align with your interests, whether it's in web development (Django, Flask), machine learning (Scikit-learn, TensorFlow, PyTorch), data engineering (Apache Spark, Airflow), or any other field. The skills you've acquired are a powerful foundation. Stay curious, keep practicing, and enjoy the endless possibilities that Python programming offers!

---
**Disclaimer:** The URLs and library names mentioned in this document are for illustrative purposes based on common knowledge and the simulated research data. While efforts were made to reflect plausible information, always refer to the official documentation and websites for the most accurate and up-to-date details. The `image_url` provided at the beginning is associated with the user's initial prompt and is used here for context as requested.